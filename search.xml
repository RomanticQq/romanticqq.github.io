<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>small tips</title>
    <url>/posts/64603/</url>
    <content><![CDATA[<ol>
<li>在pytorch中，如果用交叉熵损失，则模型的最后一层不能是<code>nn.Softmax()</code>，因为在交叉熵损失中已经内置了<code>nn.Softmax()</code>，用两次会造成损失收敛缓慢甚至不收敛；</li>
<li>给文件起名字的时候不要与安装的包的名字相同，否则导包时可以会导本地同名的文件，调用包里的方法就会报，没有发现该模块；</li>
<li>安装完augly，发现导包失败，<code>pip uninstall python-magic; pip install python-magic-bin==0.4.14</code>；</li>
<li>训练vgg16时，学习率不能设置太大，比如设置为0.001时，就会造成损失函数不下降，模型不收敛，可以设置为0.0001；</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>待解决的问题</title>
    <url>/posts/47833/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e88d6996341542558523c986c61d256f6e257478cdcb8f7cdc9b416682659bc0">165d50f05814027fb7fe5e4ae8a088d83d7abc3ea06a17389a668a8e3d42cbd6f8d055648161a39d85643d3d8c740e23b84665ec404e54cc5dfa1f5e1475d73f92404851d82d3386d0d6d5a0ffe91bdcb0dcf5c7789e18713ce75200ddade5556794861c0e1174c30737fb302b2a95f5cf905ed1ed251ad8b74b4d47e31d7fbf96b1d6bf0d6e37c55f1caba7048e4d5e3a0cf8e47f87a9b4049f40c1230532043e97b6d46442a83292d2d0e03459d1b7320b44344016053c15307bd962055f9446798b8d852cfe1c2b13fccf512009b1d7e8e4a58739745f393685a363e24ca37df909485207c880e4f66e891252fe0052e564404545388d11bf5fc6ad0445ff99c3529a706f871b14858017297eae72475779f323c2d1eec33ef0fcdde8bd89b70d06ef5f0101f1e7ac7701e45b92a0ce591084e9c2f0d7dfaab7051dee3effed8255623df4ff9d21a3aae2ee60f44e84068e7c78ee02864d6e27f4ecc81a85a15801d987d03fe763ae43d28faeef808fdd8097964621e1dcd7e8f797a19adf90ce5bcce0c67e424e15b1b823dddcb916a639bc5028c751ce1bf5bd5192935389cd5f11780ff7dbd5a25d47ab10922fa982c552f8f2706e1b0248948f83f9c1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2023春季实习面试</title>
    <url>/posts/8883/</url>
    <content><![CDATA[<h3 id="南京百家云科技有限公司"><a href="#南京百家云科技有限公司" class="headerlink" title="南京百家云科技有限公司"></a>南京百家云科技有限公司</h3><ol>
<li><p>自我介绍；</p>
<p>(第一个项目)</p>
</li>
<li><p>介绍使用YOLOv3的项目并介绍YOLOv3；</p>
</li>
<li><p>YOLOv3的图像输入大小是什么；</p>
</li>
<li><p>YOLOv5、YOLOv8都出来了为什么要用YOLOv3；</p>
</li>
<li><p>对YOLOv5熟悉吗，说一下YOLOv3与YOLOv5的区别，YOLOv5中加了哪些结构，介绍一下；</p>
</li>
<li><p>YOLOv3最后模型的输出是什么；</p>
</li>
<li><p>多分类目标和多目标分类一样吗；多分类和多标签一样吗，若不一样有什么区别；</p>
</li>
<li><p>softmax的作用是什么；为什么进行目标分类时要用softmax；</p>
</li>
<li><p>若需要给一个目标打多个标签时，应该怎么做；</p>
</li>
<li><p>更加熟悉YOLOv3还是faster-RCNN，介绍一下(回答的是faster-RCNN)；</p>
</li>
<li><p>faster-RCNN中图像的输入大小是什么；</p>
</li>
<li><p>介绍一下faster-RCNN的发展史；</p>
</li>
<li><p>你看的faster-RCNN源码中，都进行了哪些数据处理(包括在图像尺寸不满足输入大小时，图像上的标注框应该如何进行缩放)；</p>
<p>(第二个项目)</p>
</li>
<li><p>介绍另外一下另外一个项目；</p>
</li>
<li><p>该项目中所使用的数据集是什么，有多少张图片，共有多少种类，类别都是什么；</p>
</li>
<li><p>数据集使用了哪些数据增强，使用了什么库，为什么要这样做；知道这些数据增强的底层实现吗；</p>
</li>
<li><p>在项目中使用了什么方式读取图片？OpenCV和PIL这两种读取图片的方式有什么区别；</p>
</li>
<li><p>项目中使用了深度可分离卷积，介绍一下深度可分离卷积，并介绍一下它的作用；</p>
</li>
<li><p>在该项目中模型共有多少层，输入的图像大小是多少，进行了多少次下采样；</p>
</li>
<li><p>在该项目中使用了注意力机制，介绍一下；</p>
</li>
<li><p>在该项目中最后的输出是怎么样的；</p>
<p>(深度学习)</p>
</li>
<li><p>介绍一下深度学习的激活函数，有哪些优缺点；</p>
</li>
<li><p>梯度下降函数有哪些；在哪会用到梯度下降；梯度下降的参数有哪些；</p>
</li>
<li><p>学习率的作用是什么；</p>
</li>
<li><p>如何设置batch_size；图像处理在什么位置做；batch_size会调用什么函数；</p>
</li>
<li><p>目前在做什么，介绍一下它的原理，代码是如何实现的(说的是NF)；</p>
</li>
<li><p>生成对抗网络的生成器和判别器的关系；</p>
</li>
<li><p>tensorRT在转换的时候会转换成什么类型的模型；</p>
</li>
<li><p>在转换的过程中遇到了什么问题，是如何解决的；</p>
</li>
<li><p>为什么tensorRT会减少显存，增加计算量；</p>
</li>
<li><p>一阶段和两阶段的目标检测模型有什么区别；</p>
<p>(算法)</p>
</li>
<li><p>快排；</p>
<p>(其他)</p>
</li>
<li><p>你从上一次实习经历中得到了什么；</p>
</li>
<li>在上家公司实习你做了什么工作；</li>
<li>在上家公司做线材的缺陷检测使用了什么相机，光源；用了几个相机；相机和光源的位置是如何摆放的；是否用到了图像拼接；</li>
<li>在上家公司使用的可视化系统是自己开发的吗；</li>
<li>在上家公司实习的项目中遇到了什么问题；是如何解决的；</li>
<li>学习过flask框架吗；</li>
</ol>
<p>总结：这次面试时间长达100分钟，感觉比较好，虽然问的问题比较多，有一部分没有回答上来，快排也写的稀碎，但总体还是好的，能够感觉到面试官特别重视。</p>
<h3 id="梅卡曼德机器人（上海）"><a href="#梅卡曼德机器人（上海）" class="headerlink" title="梅卡曼德机器人（上海）"></a>梅卡曼德机器人（上海）</h3><ol>
<li>自我介绍；</li>
<li>防止过拟合的方法有哪些；</li>
<li>介绍一下你的项目(三个都介绍了一下)；</li>
<li>你多次提到了残差结构，介绍一下残差结构是怎么样的；</li>
<li>学习率一般设置多少，有没有自己的调参经验；过大或过小会导致什么后果；</li>
<li>介绍一下图像分类，语义分割和实例分割有什么区别；</li>
</ol>
<p>总结：这个面试很快就结束了，面试官介绍说梅卡曼德的研发主要是在北京，上海这边主要是做项目，比如采集图像2D或3D图像，交给专门的标注公司去做，标注公司做完后检查他们做的是否合格，然后通过项目区去选择合适的方法，用现成的软件设置一下超参数就可以去训练。</p>
<h3 id="武汉TCL工业研究院"><a href="#武汉TCL工业研究院" class="headerlink" title="武汉TCL工业研究院"></a>武汉TCL工业研究院</h3><ol>
<li>自我介绍；</li>
<li>介绍一下项目(几乎没有发散去问)；</li>
<li>介绍一下YOLOv3;</li>
<li>YOLOv3的三种不同尺寸的特征图分别是下采样多少；预测何种类型的物体；</li>
<li>YOLOv3的一个grid cell产生几个anchor；</li>
<li>YOLOv3中正样本和负样本是如何划分的；</li>
<li>介绍一下faster-RCNN；</li>
<li>在faster-RCNN中正负样本是如何选择的；</li>
</ol>
<h3 id="其他面试提出的有价值的问题："><a href="#其他面试提出的有价值的问题：" class="headerlink" title="其他面试提出的有价值的问题："></a>其他面试提出的有价值的问题：</h3><ol>
<li>在对缺陷进行语义分割时，若缺陷的面积很小且不规则，如何进行测量；</li>
</ol>
<h3 id="需要尽快学习的地方"><a href="#需要尽快学习的地方" class="headerlink" title="需要尽快学习的地方"></a>需要尽快学习的地方</h3><ol>
<li>学习传统的图像处理方法；</li>
<li>学习OpenCV；</li>
<li>学习3D视觉技术；</li>
<li>学习PCL点云库；</li>
<li>学习关于视觉相关的C++技术；</li>
<li>对YOLO系列和faster-RCNN系列的原理要理清楚，可以不细看代码，但原理一点要搞清楚；</li>
<li>找关于以上技术的开源项目进行学习，并掌握；</li>
<li>学习transformer、VAE、NF等模型的原理代码；</li>
<li>掌握mobilnetv2和unet的模型结构和设计思想；</li>
<li>完善简历上的项目细节；</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>实习面试</tag>
      </tags>
  </entry>
  <entry>
    <title>关于二分类和多分类的交叉熵损失</title>
    <url>/posts/5471/</url>
    <content><![CDATA[<p><strong>部分参考：<a href="https://zhuanlan.zhihu.com/p/35709485">https://zhuanlan.zhihu.com/p/35709485</a></strong></p>
<h3 id="二分类交叉熵损失"><a href="#二分类交叉熵损失" class="headerlink" title="二分类交叉熵损失"></a>二分类交叉熵损失</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/202212152125283.png" alt="image-20221215212558197"></p>
<h3 id="多分类交叉熵损失"><a href="#多分类交叉熵损失" class="headerlink" title="多分类交叉熵损失"></a>多分类交叉熵损失</h3><p>在多分类交叉熵损失函数中，预测值要先经过softmax，然后再送入交叉熵公式。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/202212152128466.png" alt="image-20221215212849429"></p>
<p><strong>总结：经过测试，在pytorch的BCELoss中并没有做sigmod或softmax，在多分类交叉熵损失函数中做了softmax。</strong></p>
<p><strong>二分类损失和多分类损失一定不能混用，使用二分类损失时的数据维度应该是一维，使用多分类损失函数时的数据维度应该是二维。</strong></p>
<p><strong>虽然二维数据时仍然可以使用二分类交叉熵损失，但是这样是不对的。同理，一维数据也可以使用多分类交叉熵损失，但是这样也是不对的。</strong></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>损失函数</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv3的理解和认识</title>
    <url>/posts/57072/</url>
    <content><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><strong>代码：<a href="https://github.com/bubbliiiing/yolo3-pytorch">https://github.com/bubbliiiing/yolo3-pytorch</a></strong></p>
<p><strong>b站：<a href="https://www.bilibili.com/video/BV1Hp4y1y788/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0a0fc78c4f646862160e365c9909f8f7">https://www.bilibili.com/video/BV1Hp4y1y788/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0a0fc78c4f646862160e365c9909f8f7</a></strong></p>
<p><strong>博客：<a href="https://blog.csdn.net/weixin_44791964/article/details/105310627">https://blog.csdn.net/weixin_44791964/article/details/105310627</a></strong></p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/202212151213379.jpg" alt="yolov3" style="zoom:100%;"></p>
<ol>
<li>主干提取网络采用的是darknet52；</li>
<li>在darknet52中，优点是采用了残差连接和1×1和3×3的卷积核连接使用，1×1和3×3的卷积核连接使用可以有效的减少参数量；</li>
<li>在检测网络中采用了多尺度特征融合，能够有效提高算法的检测精度；</li>
<li>在yolov3中有3种在不同尺寸特征图上的预测结果，以输入图像是416×416大小为例，分别会生成尺寸为52×52、26×26、13×13的特征图，分别预测小、中、大目标；</li>
</ol>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/202212151222563.jpg" alt="ab14c47c98f3d0400a3e5d44ff53426"></p>
<p><strong>损失函数包括四部分，分别为正样本坐标损失、正样本类别损失、正样本置信度损失和负样本置信度损失。</strong></p>
<p><strong>注：所有样本=正样本+负样本+忽略样本</strong></p>
<p><strong>正样本：真正预测物体的预测框；</strong></p>
<p><strong>忽略样本：不是真正预测物体的预测框，但是与真实框的最大IOU大于0.5</strong></p>
<p><strong>负样本：不是真正预测物体的预测框，但是与真实框的最大IOU小于0.5</strong></p>
<h4 id="正样本坐标损失"><a href="#正样本坐标损失" class="headerlink" title="正样本坐标损失"></a>正样本坐标损失</h4><ol>
<li>坐标是用x,y,w,h进行表示，分别为中心点坐标和框的宽高的偏移量；</li>
<li>在代码中计算损失是用的BCELoss;</li>
<li>在对标签数据进行处理时，对于没有物体的anchor，x,y,w,h,conf和cls都设置为0；</li>
<li>对小框的惩罚项：对真正预测物体的anchor进行设置，设置的值为该anchor真实的w和h的乘积；其余没有真实物体的值设置为0；</li>
<li>对4中求出的最终求出的结果，要用2减去；</li>
<li>在代码中，对小框的惩罚项到乘到标签数据的x,y,w和h上面；</li>
<li>如何惩罚小框：惩罚小框就是使损失值变大，对于存在物体的anchor的框较小时，对应的w和h也更小(因为w和h代表宽高的偏移量)，因此乘积也就更小，当用2减去该值是，所得到的的值就越大，乘到损失函数上就会使损失变大；</li>
</ol>
<h4 id="正样本类别损失"><a href="#正样本类别损失" class="headerlink" title="正样本类别损失"></a>正样本类别损失</h4><ol>
<li>正样本类别损失的计算方式采用的BCELoss;</li>
<li>计算时每个真实目标物体的类别采用的是one_hot编码的数据，预测的类别是采用的预测数据，如[0,0,1]和[0.3,0.5,0.2];</li>
</ol>
<h4 id="正样本置信度损失和负样本置信度损失"><a href="#正样本置信度损失和负样本置信度损失" class="headerlink" title="正样本置信度损失和负样本置信度损失"></a>正样本置信度损失和负样本置信度损失</h4><ol>
<li>正样本置信度损失和负样本置信度损失都直接采用BCELoss进行计算；</li>
<li>该处的置信度是该bbox是否有物体的置信度；</li>
</ol>
<h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><ol>
<li>通过dataloader获取在图片大小是1×1的条件下的x,y,w,h;</li>
<li>然后转化为在当前特征图上的相对应的偏移量traget；</li>
<li>把9种不同大小的anchor和真实框进行IOU(该处的IOU是两个矩形的中心点重合)，获取每个真实框与anchor最大IOU的索引；</li>
<li>通过target获取真实框所在特征图的grid cell的位置；</li>
<li>分别对y_true和noobj_mask进行设置(noobj_mask表示没有物体的索引)；</li>
<li>通过预测值计算在当前特征图上的x,y,w,h，得出预测值;</li>
<li>在当前特征图下计算真实框和anchor的IOU(普通IOU；若真实框为3，anchor为100，则结果的shape为[3,100]);</li>
<li>通过7获取每个先验框与真实框的最大重合度；若最大重合度的IOU大于0.5，则忽略该预测框；</li>
<li>将以上得到的值交给损失函数去计算；</li>
</ol>
<h3 id="预测阶段"><a href="#预测阶段" class="headerlink" title="预测阶段"></a>预测阶段</h3><ol>
<li>预测出偏移量；</li>
<li>得到中心点的坐标和宽高(在当前特征图上)；</li>
<li>将2中得到的坐标进行归一化(即相当于放在1×1的特征图上)；</li>
<li>通过处理得到预测框左上角和右下角的坐标；</li>
<li>通过置信度进行抑制(具体细节：让每个anchor的置信度和它预测出各个类别的概率相乘的结果去和置信度分数去比较，大于置信度分数则保留，否则则剔除)；</li>
<li>然后按照类别进行非极大值抑制nms(nms只要抑制IOU，但是要传conf)，获取最终的结果；</li>
<li><p>通过对坐标进行计算，得到在原图(真正图片)上的中心点和宽高；</p>
<h3 id="目标检测常见名词区分"><a href="#目标检测常见名词区分" class="headerlink" title="目标检测常见名词区分"></a>目标检测常见名词区分</h3></li>
</ol>
<p>bbox：指预测框(在anchor的基础上调整过后的预测框)；</p>
<p>grid cell：指图像划分成的小格格；</p>
<p>ground truth：指人工标注框；</p>
<p>anchor：指初始化的预测框；</p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLO</tag>
      </tags>
  </entry>
  <entry>
    <title>nn.DataParallel的坑</title>
    <url>/posts/undefined/</url>
    <content><![CDATA[<p>nn.DataParallel是pytorch使用多gpu训练时所使用的方法，但是使用nn.DataParallel之后，模型的读取就会有所不同。</p>
<h3 id="当训练时没有使用nn-DataParallel，而测试时使用"><a href="#当训练时没有使用nn-DataParallel，而测试时使用" class="headerlink" title="当训练时没有使用nn.DataParallel，而测试时使用"></a>当训练时没有使用nn.DataParallel，而测试时使用</h3><p>这种情况就会报错，应该先把模型加载进来，在使用nn.DataParallel</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.load_state_dict(torch.load(save_path))</span><br><span class="line">model = nn.DataParallel(model, device_ids=[<span class="number">0</span>, <span class="number">1</span>]) </span><br></pre></td></tr></table></figure>
<p><strong>造成这些问题的根本原因是因为模型经过nn.DataParallel后，权重参数的形式会发生变化</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module.features<span class="number">.0</span>.weight <span class="comment"># 经过nn.DataParallel</span></span><br><span class="line">features<span class="number">.0</span>.weight <span class="comment"># 没有经过nn.DataParallel</span></span><br><span class="line"><span class="comment"># 没有经过nn.DataParallel的模型，没有model.module这个属性</span></span><br><span class="line"><span class="comment"># 经过nn.DataParallel的模型，给模型传参时使用model.module(params)，比如给forward传数据时</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>torch.permute和torch.reshape的区别</title>
    <url>/posts/17446/</url>
    <content><![CDATA[<h1 id="torch-permute"><a href="#torch-permute" class="headerlink" title="torch.permute"></a>torch.permute</h1><p>permute作用为调换Tensor的维度，参数为调换的维度。例如对于一个二维Tensor来说，调用tensor.permute(1,0)意为将1轴（列轴）与0轴（行轴）调换，相当于进行转置</p>
<h1 id="torch-reshape"><a href="#torch-reshape" class="headerlink" title="torch.reshape"></a>torch.reshape</h1><p>reshape和view得到的tensor并不是转置的效果，而是相当于将原tensor的元素按行取出，然后按行放入到新形状的tensor中。</p>
<h1 id="torch-reshape和torch-view的区别"><a href="#torch-reshape和torch-view的区别" class="headerlink" title="torch.reshape和torch.view的区别"></a>torch.reshape和torch.view的区别</h1><p>torch的view()与reshape()方法都可以用来重塑tensor的shape，区别就是使用的条件不一样。</p>
<p>view()方法只适用于满足连续性条件的tensor，并且该操作不会开辟新的内存空间，只是产生了对原存储空间的一个新别称和引用，返回值是视图。</p>
<p>reshape()即可以处理连续内存的数据，也可以处理不是连续内存空间的数据；当内存空间连续时和view()相同；当数据内存空间不连续时，就会对数据进行复制到连续内存空间上，然后再进行维度的改变。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>torch函数</tag>
      </tags>
  </entry>
  <entry>
    <title>归一化的方法</title>
    <url>/posts/29435/</url>
    <content><![CDATA[<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/202211021208331.png" alt="image-20221102120054647"></p>
<h1 id="Batch-Norm"><a href="#Batch-Norm" class="headerlink" title="Batch Norm"></a>Batch Norm</h1><ul>
<li>按照不同的通道进行批归一化；</li>
<li>比如输入是【2,3,4,5】，输入两张三通道的图像，取这两张图像的第一个通道组合起来做一次归一化，取这两张图像的第二个通道组合起来做一次归一化……</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.randn([<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">bn = torch.nn.BatchNorm2d(<span class="number">3</span>)</span><br><span class="line">res = bn(x)</span><br><span class="line">res1 = res[:, <span class="number">0</span>, ...]</span><br><span class="line">print(res1)</span><br><span class="line"></span><br><span class="line">x1 = x[:, <span class="number">0</span>, ...]</span><br><span class="line">u = x1.mean()</span><br><span class="line">s = (x1-u).<span class="built_in">pow</span>(<span class="number">2</span>).mean()</span><br><span class="line">res2 = (x1-u)/torch.sqrt(s+<span class="number">1e-5</span>)</span><br><span class="line">print(res2)</span><br><span class="line"><span class="comment"># res1 == res2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Layer-Norm"><a href="#Layer-Norm" class="headerlink" title="Layer Norm"></a>Layer Norm</h1><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/202211021220230.png" alt="image-20221102122020184"></p>
<p>假设我们的输入为(1, 3, 5, 5)的变量，并对其进行LayerNorm，一般来说有两种归一化的方式。如下图所示，左边为第一种归一化方法，对所有channel所有像素计算；右边为第二种归一化方法，对所有channel的每个像素分别计算</p>
<ul>
<li>计算一个batch中所有channel中所有参数的均值和方差，然后进行归一化，即(3, 5, 5)</li>
<li>计算一个batch中所有channel中的每一个参数的均值和方差进行归一化，即(3, 1, 1)，计算25次</li>
</ul>
<p><a href="!https://blog.csdn.net/weixin_41978699/article/details/122778085">参考</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>归一化</tag>
      </tags>
  </entry>
  <entry>
    <title>安装tensorRT</title>
    <url>/posts/54278/</url>
    <content><![CDATA[<ol>
<li>下载cuda、cudnn、tensorrt；</li>
<li>把cudnn下的lib、bin、include对应复制到cudn下面；</li>
<li>把tensorrt的lib加到环境变量中；</li>
<li>安装pycuda时去官网下载whl文件，直接装可能会报错；如果cuda版本太高，用pycuda最新的版本就可以，不用回退cuda版本；</li>
<li>安装下载好的tensorrt；</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tensorRT</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU内存占用测试报告</title>
    <url>/posts/48938/</url>
    <content><![CDATA[<p><strong>显卡：</strong>NVIDIA GeForce GTX 1070</p>
<p><strong>batch-size：</strong>4</p>
<p><strong>GPU内存：</strong>8G</p>
<p><strong>模型：</strong>resnet101</p>
<p><strong>数据集：</strong>flower_data</p>
<p><strong>img.shpe:</strong> (3, 512, 512)</p>
<h1 id="测试情况"><a href="#测试情况" class="headerlink" title="测试情况"></a>测试情况</h1><h5 id="默认-不使用混合精度、jit、tensorRT，函数：test-model"><a href="#默认-不使用混合精度、jit、tensorRT，函数：test-model" class="headerlink" title="默认(不使用混合精度、jit、tensorRT，函数：test_model)"></a>默认(不使用混合精度、jit、tensorRT，函数：test_model)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">GPU内存占用</th>
<th style="text-align:center">运行时间(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6.6G</td>
<td style="text-align:center">25s</td>
</tr>
</tbody>
</table>
</div>
<h5 id="混合精度-只使用混合精度，函数：test-autocast-model"><a href="#混合精度-只使用混合精度，函数：test-autocast-model" class="headerlink" title="混合精度(只使用混合精度，函数：test_autocast_model)"></a>混合精度(只使用混合精度，函数：test_autocast_model)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">GPU内存占用</th>
<th style="text-align:center">运行时间(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.2G</td>
<td style="text-align:center">27s</td>
</tr>
</tbody>
</table>
</div>
<h5 id="jit-只使用jit，函数：test-jit-model"><a href="#jit-只使用jit，函数：test-jit-model" class="headerlink" title="jit(只使用jit，函数：test_jit_model)"></a>jit(只使用jit，函数：test_jit_model)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">GPU内存占用</th>
<th style="text-align:center">运行时间(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2.0G</td>
<td style="text-align:center">25s</td>
</tr>
</tbody>
</table>
</div>
<h5 id="jit-混合精度-test-antocast-jit-model"><a href="#jit-混合精度-test-antocast-jit-model" class="headerlink" title="jit+混合精度(test_antocast_jit_model)"></a>jit+混合精度(test_antocast_jit_model)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">GPU内存占用</th>
<th style="text-align:center">运行时间(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2.0G</td>
<td style="text-align:center">25s</td>
</tr>
</tbody>
</table>
</div>
<h5 id="tensorRT-只使用tensorRT，函数：test-trt-model"><a href="#tensorRT-只使用tensorRT，函数：test-trt-model" class="headerlink" title="tensorRT(只使用tensorRT，函数：test_trt_model)"></a>tensorRT(只使用tensorRT，函数：test_trt_model)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">GPU内存占用</th>
<th style="text-align:center">运行时间(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3.3G</td>
<td style="text-align:center">5s</td>
</tr>
</tbody>
</table>
</div>
<h5 id="混合精度-tensorRT-函数：test-autocast-trt-model"><a href="#混合精度-tensorRT-函数：test-autocast-trt-model" class="headerlink" title="混合精度+tensorRT(函数：test_autocast_trt_model)"></a>混合精度+tensorRT(函数：test_autocast_trt_model)</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">GPU内存占用</th>
<th style="text-align:center">运行时间(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3.3G</td>
<td style="text-align:center">5s</td>
</tr>
</tbody>
</table>
</div>
<h5 id><a href="#" class="headerlink" title=" "></a> </h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span>():</span></span><br><span class="line">    model = models.resnet101(pretrained=<span class="literal">True</span>).<span class="built_in">eval</span>().to(device)</span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(dataloaders[<span class="string">&#x27;valid&#x27;</span>]):</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_autocast_model</span>():</span></span><br><span class="line">    model = models.resnet101(pretrained=<span class="literal">True</span>).<span class="built_in">eval</span>().to(device)</span><br><span class="line">    <span class="keyword">with</span> torch.autocast(device_type=<span class="string">&quot;cuda&quot;</span>):</span><br><span class="line">        <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(dataloaders[<span class="string">&#x27;valid&#x27;</span>]):</span><br><span class="line">            inputs = inputs.to(device)</span><br><span class="line">            outputs = model(inputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_jit_model</span>():</span></span><br><span class="line">    model = models.resnet101(pretrained=<span class="literal">True</span>).<span class="built_in">eval</span>().to(device)</span><br><span class="line">    model = torch.jit.script(model)</span><br><span class="line">    model = torch.jit.freeze(model)</span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(dataloaders[<span class="string">&#x27;valid&#x27;</span>]):</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_antocast_jit_model</span>():</span></span><br><span class="line">    model = models.resnet101(pretrained=<span class="literal">True</span>).<span class="built_in">eval</span>().to(device)</span><br><span class="line">    <span class="keyword">with</span> torch.cuda.amp.autocast(cache_enabled=<span class="literal">False</span>):</span><br><span class="line">        model = torch.jit.script(model)</span><br><span class="line">    model = torch.jit.freeze(model)</span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(dataloaders[<span class="string">&#x27;valid&#x27;</span>]):</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_trt_model</span>():</span></span><br><span class="line">    model = models.resnet101(pretrained=<span class="literal">True</span>).<span class="built_in">eval</span>().to(device)</span><br><span class="line">    x = torch.ones((<span class="number">1</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)).cuda()</span><br><span class="line">    model_trt = torch2trt(model, [x])</span><br><span class="line">    model = TRTModule()</span><br><span class="line">    model.load_state_dict(model_trt.state_dict())</span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(dataloaders[<span class="string">&#x27;valid&#x27;</span>]):</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_autocast_trt_model</span>():</span></span><br><span class="line">    model = models.resnet101(pretrained=<span class="literal">True</span>).<span class="built_in">eval</span>().to(device)</span><br><span class="line">    x = torch.ones((<span class="number">1</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>)).cuda()</span><br><span class="line">    model_trt = torch2trt(model, [x])</span><br><span class="line">    model = TRTModule()</span><br><span class="line">    model.load_state_dict(model_trt.state_dict())</span><br><span class="line">    <span class="keyword">with</span> torch.autocast(device_type=<span class="string">&quot;cuda&quot;</span>):</span><br><span class="line">        <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(dataloaders[<span class="string">&#x27;valid&#x27;</span>]):</span><br><span class="line">            inputs = inputs.to(device)</span><br><span class="line">            outputs = model(inputs)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>2022.8.24面试</title>
    <url>/posts/46244/</url>
    <content><![CDATA[<ol>
<li>YOLO系列；</li>
<li>faster-rcnn系列；</li>
<li>元组和列表的区别；</li>
<li>列表去重；</li>
<li>静态方法；</li>
<li>项目经验；</li>
<li>dataset和dataloader；</li>
<li>opencv;</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>对dataframe数据集构建dataset</title>
    <url>/posts/62810/</url>
    <content><![CDATA[<p><a href="https://github.com/RomanticQq/dataframe">github代码demo</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@time : 2022/8/22 20:58</span></span><br><span class="line"><span class="string">@author : fuqiang</span></span><br><span class="line"><span class="string">@file : dataset.py</span></span><br><span class="line"><span class="string">@project : test</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure>
<p>​<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainDataset</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data_path, width_height, classes</span>):</span></span><br><span class="line">        self.df = pd.read_pickle(data_path)</span><br><span class="line">        self.w_h = width_height</span><br><span class="line">        self.classes = classes</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        image = self.df.iloc[item, <span class="number">0</span>]</span><br><span class="line">        label = self.df.iloc[item, <span class="number">1</span>]</span><br><span class="line">        image = Image.fromarray(image).resize((self.w_h, self.w_h), resample=Image.NEAREST)</span><br><span class="line">        image = np.array(image)</span><br><span class="line">        image = torch.from_numpy(image)</span><br><span class="line">        label = torch.tensor(label)</span><br><span class="line">        image = F.one_hot(image.to(torch.int64), <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># label = F.one_hot(label.to(torch.int64), self.classes)</span></span><br><span class="line">        image = np.array(image).transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)).astype(dtype=np.float32)</span><br><span class="line">        image = torch.FloatTensor(image).contiguous()</span><br><span class="line">        <span class="comment"># label = label.contiguous()</span></span><br><span class="line">        <span class="keyword">return</span> image, label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.df)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>dataframe</category>
      </categories>
      <tags>
        <tag>dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>对dataframe数据的读取、处理和保存</title>
    <url>/posts/52233/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkl、csv、xlsx等文件都可使用pandas进行读取，读取后都为dataframe数据类型</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">df = pd.read_pickle(<span class="string">&#x27;data/WM-811K-simple-test.pkl&#x27;</span>)</span><br><span class="line"><span class="comment"># 新增一列 列名为failureNum 并把原先列名为failureType的数据赋值给新列</span></span><br><span class="line">df[<span class="string">&#x27;failureNum&#x27;</span>] = df.failureType</span><br><span class="line">mapping = &#123;<span class="string">&#x27;Center&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;Donut&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Edge-Loc&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Edge-Ring&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">           <span class="string">&#x27;Loc&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;Near-full&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;Random&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;Scratch&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;none&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="comment"># 根据mapping映射关系对新列的数据内容进行修改</span></span><br><span class="line">df = df.replace(&#123;<span class="string">&#x27;failureNum&#x27;</span>: mapping&#125;)</span><br><span class="line"><span class="comment"># 通过条件获取筛选过后的列</span></span><br><span class="line">df = df[(df[<span class="string">&#x27;failureNum&#x27;</span>] &gt;= <span class="number">0</span>) &amp; (df[<span class="string">&#x27;failureNum&#x27;</span>] &lt;= <span class="number">8</span>)]</span><br><span class="line"><span class="comment"># 对某一列进行删除</span></span><br><span class="line">df = df.drop([<span class="string">&#x27;failureType&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 对处理过后的数据进行保存</span></span><br><span class="line">df.to_pickle(<span class="string">&#x27;./data/WM-811K-torch.pkl&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dataframe</category>
      </categories>
      <tags>
        <tag>dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>git的基本使用</title>
    <url>/posts/29656/</url>
    <content><![CDATA[<h4 id="1-删除仓库文件"><a href="#1-删除仓库文件" class="headerlink" title="1.删除仓库文件"></a>1.删除仓库文件</h4><p>先删除本地文件-&gt;git add -u</p>
<h4 id="2-创建test分支"><a href="#2-创建test分支" class="headerlink" title="2.创建test分支"></a>2.创建test分支</h4><p>列出所有分支git branch -a(带*绿色的为当前分支，白色和绿色的为当前分支，红色所有远端分支)-&gt;创建test分支git branch test-&gt;切换分支git checkout test-&gt;提交分支git push origin test</p>
<h4 id="3-把test分支合并到master分支"><a href="#3-把test分支合并到master分支" class="headerlink" title="3.把test分支合并到master分支"></a>3.把test分支合并到master分支</h4><p>git merge test</p>
<h4 id="4-删除test分支"><a href="#4-删除test分支" class="headerlink" title="4.删除test分支"></a>4.删除test分支</h4><p>切换非删除的分支<br>git branch -D test 删除本地分支<br>git push —delete test 删除远端分支  删除远端分支时，本地分支不会被删除</p>
<h4 id="5-从github下载代码的时候一定要使用ssh地址，使用https地址的时候可能会出现问题"><a href="#5-从github下载代码的时候一定要使用ssh地址，使用https地址的时候可能会出现问题" class="headerlink" title="5.从github下载代码的时候一定要使用ssh地址，使用https地址的时候可能会出现问题"></a>5.从github下载代码的时候一定要使用ssh地址，使用https地址的时候可能会出现问题</h4><h4 id="6-从仓库拉去代码"><a href="#6-从仓库拉去代码" class="headerlink" title="6.从仓库拉去代码"></a>6.从仓库拉去代码</h4><p>git pull</p>
<h4 id="7-把代码推送到仓库"><a href="#7-把代码推送到仓库" class="headerlink" title="7.把代码推送到仓库"></a>7.把代码推送到仓库</h4><p>把文件添加到缓冲区 git add 文件名<br>把文件添加到本地仓库 git commit -a 本地提交的注释<br>把文件推送到仓库git push(origin 当前分支名)(亲测，如果是分支第一次提交不能省略，可能是因为要把新分支和代码同时推上去，否则括号内的内容可省)</p>
<h4 id="8-恢复被修改的文件"><a href="#8-恢复被修改的文件" class="headerlink" title="8.恢复被修改的文件"></a>8.恢复被修改的文件</h4><p>git checkout .(恢复被修改的所有文件)<br>git checkout — 文件名/文件夹名(恢复被修改的文件名或则文件夹名)</p>
<h4 id="9-内容回滚"><a href="#9-内容回滚" class="headerlink" title="9.内容回滚"></a>9.内容回滚</h4><p>git reset HEAD^ 所有内容回退到上一个版本<br>git reset HEAD^ 文件名 具体文件回退到上一个版本<br>git reset 哈希值 回退到产生这个哈希值的状态</p>
<h4 id="10-如何拉取远端所有分支"><a href="#10-如何拉取远端所有分支" class="headerlink" title="10.如何拉取远端所有分支"></a>10.如何拉取远端所有分支</h4><p>get checkout -b 分支名  origin/分支名 切换到远端的分支并在本地命名</p>
<h4 id="这些平时就已经够用了，更加高级的用法用到时可自行百度"><a href="#这些平时就已经够用了，更加高级的用法用到时可自行百度" class="headerlink" title="这些平时就已经够用了，更加高级的用法用到时可自行百度"></a>这些平时就已经够用了，更加高级的用法用到时可自行百度</h4>]]></content>
      <tags>
        <tag>-- git</tag>
      </tags>
  </entry>
  <entry>
    <title>对多层神经网络连接的理解</title>
    <url>/posts/63265/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = CNN()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cnn</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Test, self).__init__()</span><br><span class="line">        self.conv = cnn.conv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = torch.randn([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">test = Test(net)</span><br><span class="line">res = test(a)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<p>Test类直接接受是CNN()实例化后的net，相当于把CNN()的网络结构作为参数传给了Test()，这样在CNN()中就不用写forward()，即使写了也不起作用，因为对于test对象来说，它的网络结构是Test()定义的，其前向传播必须在Test()中进行定义。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>卷积神经网络</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>python的mro、super和self</title>
    <url>/posts/48741/</url>
    <content><![CDATA[<h3 id="mro"><a href="#mro" class="headerlink" title="mro"></a>mro</h3><p><strong>mro是每一个类会把它所有的父类和自己做一个线性化serialization，也就是把所有的继承类和自己做一个排队，这个排队要保证自己是最高优先级。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义两个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;B&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 情况1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = M()</span><br><span class="line">m.say() <span class="comment"># A</span></span><br><span class="line"><span class="comment"># 此处M.mro()是M,A,B(因为在继承的时候A在前，所以A的优先级高于B)</span></span><br><span class="line"><span class="comment"># 因为m调用了say函数，会按照m所在类的mro的顺序从前到后在类里找say函数,先在类A里找到了，因此输出为A</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 情况2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>(<span class="params">C,B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = M()</span><br><span class="line">m.say() <span class="comment"># A</span></span><br><span class="line"><span class="comment"># 此处M.mro()是M,C,A,B(因为在M继承C和B的时候先继承的C,所以C及C的父类的优先级都高于B)</span></span><br><span class="line"><span class="comment"># 因为m调用了say函数，会按照m所在类的mro的顺序从前到后在类里找say函数,先在类A里找到了，因此输出为A</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 情况3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>(<span class="params">C,D</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = M()</span><br><span class="line">m.say() <span class="comment"># D</span></span><br><span class="line"><span class="comment"># 此处M.mro()是M,C,D,A</span></span><br><span class="line"><span class="comment"># 因为M继承了C,D   C继承了A  D继承了A</span></span><br><span class="line"><span class="comment"># C,D都继承了A,那么A的优先级以A最后出现的位置为准</span></span><br><span class="line"><span class="comment"># 因此M,C,D,A先在D中找到了say函数</span></span><br><span class="line"><span class="comment"># 这可能有一个疑问：为什么C已经继承A了，那么C中不是应该有A中的say函数吗？为什么不是输出A？</span></span><br><span class="line"><span class="comment"># 在这里只有找到了类里真真正正存在的该函数才可以，继承关系是不可以的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 情况4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>(<span class="params">C, D</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样的写法是会报错的，因为当继承相同的父类时，顺序一定要相同</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>每个类只会按排列好的类的优先级去执行自己类里面的函数，若B继承A，B里面没有say函数而A里面有，那么即使B的优先级高，B也不能执行say函数，只能优先级到A时，自己调用自己类里的say函数；</li>
<li>当存在多继承时，在当前类的继承关系中先出现的类的优先级高（情况1）；</li>
<li>当存在A被多个类继承时，A的优先级由最后一次出现的位置决定（情况3）；</li>
</ol>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">super(class, object/class).__init__([参数])</span><br><span class="line"><span class="comment"># 参数1：决定了在mro链上从哪个类的下一个开始查找__init__函数</span></span><br><span class="line"><span class="comment"># 参数2：决定了这一个函数bind到哪一个object或则class上，同时决定了使用哪一个mro</span></span><br><span class="line"><span class="comment"># 参数3：需给找到的__init__传的参数</span></span><br><span class="line"><span class="comment"># 参数1和参数2有时候是可以省略的，当省略时，参数1为当前的类名，参数2为该所在函数第一个参数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">super</span>(B, self).__init__(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = B(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">16</span>)</span><br><span class="line">print(c.name)</span><br><span class="line">print(c.age)</span><br><span class="line"><span class="comment"># 在类B中，super(B, self).__init__(name)和super().__init__(name)的作用是相同的</span></span><br><span class="line"><span class="comment"># super的执行流程(以本段代码中的super为例)：首先它要从self这个object中拿到mro，然后</span></span><br><span class="line"><span class="comment">#从类B的后一个class开始查找__init__函数，当找到__init__函数后进行赋值，然后再把__init__函数bind到</span></span><br><span class="line"><span class="comment">#self上；在这个例子中，先通过self拿到mro(B,A)，然后从B后面的类开始查找，即A类中有__init__函数，然后</span></span><br><span class="line"><span class="comment">#对__init__函数中的name进行赋值，并返回给self</span></span><br></pre></td></tr></table></figure>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p><a href="https://www.cnblogs.com/nemolmt/p/6646764.html">在类内用类名和self的区别</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>面试【2022.6.10】</title>
    <url>/posts/29098/</url>
    <content><![CDATA[<ol>
<li>BN层的作用；</li>
<li>faster-RCNN中roi pooling层是如何实现的；</li>
<li>处理图像的方法有哪些；</li>
<li>YOLO和faster-RCNN的区别；</li>
<li>YOLOv5各个功能模块的介绍；</li>
<li>常用的激活函数有哪些，有什么优点；</li>
<li>IOU是如何定义的；</li>
<li>对Transformer的理解；</li>
<li>写一个处理数据集的类，1000张图片，缩放到100 * 100，格式为RGB，划分为训练集和验证集；</li>
<li>写一个简单的神经网络模型；</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv4</title>
    <url>/posts/63321/</url>
    <content><![CDATA[<h3 id="Bag-of-freebies-BOF"><a href="#Bag-of-freebies-BOF" class="headerlink" title="Bag of freebies(BOF)"></a>Bag of freebies(BOF)</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524141933.png" alt></p>
<h4 id="Mosaic-data-augmentation"><a href="#Mosaic-data-augmentation" class="headerlink" title="Mosaic data augmentation"></a>Mosaic data augmentation</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524141948.png" alt></p>
<p>Mixup：让两张图片的像素值对应相加，生成一张新的图片；</p>
<p>Cutout：对一张图片的部分进行遮挡；</p>
<p>CutMix：把多张图片进行缩放，拼接到一张图片上；</p>
<h4 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524142001.png" alt></p>
<p>Random Erase：用随机值或训练集的平均像素替换图像的区域；</p>
<p>Hide and Seek：根据概率设置随机隐藏一些补丁；</p>
<h3 id="Self-adversarial-training-SAT"><a href="#Self-adversarial-training-SAT" class="headerlink" title="Self-adversarial-training(SAT)"></a>Self-adversarial-training(SAT)</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220609113938.png" alt></p>
<p>系数要足够小</p>
<h3 id="DropBlock"><a href="#DropBlock" class="headerlink" title="DropBlock"></a>DropBlock</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220609114052.png" alt></p>
<p>之前是随机失活一个像素点，但是周围的像素点还存在，其实对整个图像的影响并不大；</p>
<p>现在随机吃掉一个区域，使网络的性能更好。</p>
<h3 id="Label-Smoothing"><a href="#Label-Smoothing" class="headerlink" title="Label Smoothing"></a>Label Smoothing</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524142442.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524142625.png" alt></p>
<p>平滑标签，不让边界感那么强，可以提高图像的识别率；</p>
<p>这个0.1的系数是自己设置的；</p>
<h3 id="IOU损失"><a href="#IOU损失" class="headerlink" title="IOU损失"></a>IOU损失</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220609114132.png" alt></p>
<h3 id="GIOU损失"><a href="#GIOU损失" class="headerlink" title="GIOU损失"></a>GIOU损失</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524142827.png" alt></p>
<p><strong>重点：</strong>是在不重叠的情况下，预测框向真实框前进，不重叠，不重叠！！！！</p>
<p>当重叠时，不能反应出来情况的好坏；</p>
<h3 id="DIOU损失"><a href="#DIOU损失" class="headerlink" title="DIOU损失"></a>DIOU损失</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524143429.png" alt></p>
<h3 id="CIOU损失"><a href="#CIOU损失" class="headerlink" title="CIOU损失"></a>CIOU损失</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524144750.PNG" alt></p>
<h3 id="DIOU-NMS"><a href="#DIOU-NMS" class="headerlink" title="DIOU-NMS"></a>DIOU-NMS</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220609114150.png" alt></p>
<h3 id="SOFT-NMS"><a href="#SOFT-NMS" class="headerlink" title="SOFT-NMS"></a>SOFT-NMS</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524150424.png" alt></p>
<p>先不直接剔除，而是降低置信度，再给一次机会。</p>
<h3 id="SPPNet"><a href="#SPPNet" class="headerlink" title="SPPNet"></a>SPPNet</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524150602.png" alt></p>
<p>虽然输出的图像尺寸大小可能不一样，但是通过最大池化来满足最终输入特征图的大小是一样的。</p>
<h3 id="CSPNet"><a href="#CSPNet" class="headerlink" title="CSPNet"></a>CSPNet</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524151021.png" alt></p>
<p>把特征图平均分成两部分，一部分什么都不做，另外一部分经过卷积进行输出，虽然精度上可能有所降低，但是速度上会加快很多，但是结果表现精度可能并没有降低，还有一点点升高。</p>
<h3 id="CBAM"><a href="#CBAM" class="headerlink" title="CBAM"></a>CBAM</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524151400.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524151814.png" alt></p>
<p>Channel Attention Module:对不同特征图产生一个概率，这个概率值表示对不同特征图的关注度；</p>
<p>SAM：对于特征图的不同位置的注意力机制；</p>
<h3 id="PAN"><a href="#PAN" class="headerlink" title="PAN"></a>PAN</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524151909.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524151930.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524152214.png" alt></p>
<h3 id="激活函数MISH"><a href="#激活函数MISH" class="headerlink" title="激活函数MISH"></a>激活函数MISH</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524152239.png" alt></p>
<h3 id="eliminate-grid-sensitivity"><a href="#eliminate-grid-sensitivity" class="headerlink" title="eliminate grid sensitivity"></a>eliminate grid sensitivity</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524152333.png" alt></p>
<p>在σ(ty)前加上大于1的系数；</p>
<h3 id="整体网络架构"><a href="#整体网络架构" class="headerlink" title="整体网络架构"></a>整体网络架构</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220524152605.png" alt></p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLO</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移学习的基本策略</title>
    <url>/posts/30065/</url>
    <content><![CDATA[<h3 id="迁移学习的基本策略"><a href="#迁移学习的基本策略" class="headerlink" title="迁移学习的基本策略"></a>迁移学习的基本策略</h3><ul>
<li>构造数据集<ul>
<li>是否需要对数据进行处理</li>
</ul>
</li>
<li>初始化模型<ul>
<li>加载原始模型</li>
</ul>
</li>
<li>设置需要冻住的层</li>
<li>是否需要GPU运算</li>
<li>设置迭代器和损失函数</li>
<li>进行训练<ul>
<li>加载需要迁移学习的模型</li>
<li>对训练集进行训练</li>
<li>对验证集进行应该验证</li>
<li>保存验证集上准确率最高的模型</li>
<li>保存模型</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv3</title>
    <url>/posts/13592/</url>
    <content><![CDATA[<h3 id="Darknet53"><a href="#Darknet53" class="headerlink" title="Darknet53"></a>Darknet53</h3><p>YOLOv3采用了Darknet53为主干网络；</p>
<h3 id="多scale"><a href="#多scale" class="headerlink" title="多scale"></a>多scale</h3><p>在YOLOv3上设计了3种scale，分别为特征图大小13 <em> 13、26 </em> 26、52 * 52上进行大、中、小目标预测；</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220517124109.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220517122901.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220517124855.jpg" alt></p>
<h3 id="Residual-module"><a href="#Residual-module" class="headerlink" title="Residual module"></a>Residual module</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220517123021.png" alt></p>
<p>残差网络，会有A(保存原来的不进行任何操作),B两种通道，然后再合并，即使F(x)不起作用，还会保存以前的输出结果。</p>
<p><strong>注：</strong>使用残差网络，不能保证效果一定有多大提升，但是至少不会差。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220517152650.jpg" alt></p>
<ul>
<li>YOLOv3网络的输入尺寸为 (m,416,416,3), 其中m代表每个batch中图像数目,m=1,代表每个batch处理1张输入图像；</li>
<li>YOLOv3分3个尺度进行预测, 3个尺度的特征图的大小依次为13X13,26X26以及52X52；</li>
<li>YOLOv3中每个cell预测3个bounding box,每个bounding box 可以表示为6元组 <img src="https://www.zhihu.com/equation?tex=%28t_x%2Ct_y%2Ct_w%2Ct_h%2Cp_c%2Cc%29" alt="[公式]"> ；</li>
<li>在COCO数据集中一共有80个类别,此时我们将c扩展成80维向量,这样我们每个bounding box可以用85维向量进行表示；</li>
<li>特征图大小为13 <em> 13，可以预测169(13 </em> 13)个物体，然后依次类推；</li>
</ul>
<h3 id="先验眶的生成"><a href="#先验眶的生成" class="headerlink" title="先验眶的生成"></a>先验眶的生成</h3><p>先使用K-means方法生成9个先验框，然后按照大小进行排序，分给3个不同的scale。</p>
<h3 id="logistic"><a href="#logistic" class="headerlink" title="logistic"></a>logistic</h3><p>Softmax实现物体单分类最后的评判， Softmax能够确保所有物体的预测概率之和为1，比如一个物体的预测是狗的概率是80%，那么是其他物体的概率之和为20%。这就是单标签概率。</p>
<p>然后，对于多标签预测，比如，一个物体是狗的概率是80%，是狼狗的概率是70%，是猎狗的概率是75%，像这样的分类判决，Softmax就无法胜任了。</p>
<p>YOLO V3使用了logistic激活函数替换了softmax函数，把物体的联合的多分类，变成独立的二分类，从而实现对物体多标签的支持<br>(<a href="https://blog.csdn.net/HiWangWenBing/article/details/122226224">此部分参考YOLO V3 - 网络结构、原理、改进的全新、全面、通俗、结构化讲解</a>)</p>
<h5 id="逻辑回归中的基本构造函数"><a href="#逻辑回归中的基本构造函数" class="headerlink" title="逻辑回归中的基本构造函数"></a>逻辑回归中的基本构造函数</h5><p>在逻辑回归算法中，选用的基本函数就是sigmoid函数</p>
<script type="math/tex; mode=display">
y=\frac{1}{1+e^{-x}}</script><p>该函数用于预测输入x后标签y的概率，注意，这里的x并非是数据集的原始数据输入，而是乘以了参数θ之后的值，即 x = X ⋅ θ,因此逻辑回归的基本函数为：</p>
<script type="math/tex; mode=display">
y=\frac{1}{1+e^{-θx}}</script>]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLO</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv2</title>
    <url>/posts/62937/</url>
    <content><![CDATA[<h3 id="batch-norm"><a href="#batch-norm" class="headerlink" title="batch norm"></a>batch norm</h3><p>舍弃全连接层和dropout，每次卷积后加入batch normalization。</p>
<h4 id="batch-norm的作用"><a href="#batch-norm的作用" class="headerlink" title="batch norm的作用"></a>batch norm的作用</h4><p>具有统一规格的数据能让神经网络更好地学习到数据的规律；批归一化在非线性激活函数前，使梯度不会出线为0；</p>
<h3 id="高分辨率预训练分类网络"><a href="#高分辨率预训练分类网络" class="headerlink" title="高分辨率预训练分类网络"></a>高分辨率预训练分类网络</h3><p>目前的大部分检测模型都会使用主流分类网络（如vgg、resnet）在ImageNet上的预训练模型作为特征提取器,而这些分类网络大部分都是以小于256×256的图片作为输入进行训练的，低分辨率会影响模型检测能力。</p>
<p>YOLO v2将输入图片的分辨率提升448×448，为了使网络适应新的分辨率，YOLO v2先在ImageNet上以224×224进行训练，然后再以448×448的分辨率对网络进行10个epoch的微调，让网络适应高分辨率的输入。通过使用高分辨率的输入，YOLO v2的mAP提升了约4%。</p>
<h3 id="采用Anchor-Box"><a href="#采用Anchor-Box" class="headerlink" title="采用Anchor Box"></a>采用Anchor Box</h3><p>anchor box是通过对真实框聚类得到的，得到5种不同大小的anchor box。</p>
<p>anchor box只有w和h，没有中心点。</p>
<h3 id="尺寸聚类"><a href="#尺寸聚类" class="headerlink" title="尺寸聚类"></a>尺寸聚类</h3><p>聚类的目的是为了提高选取的Anchor Box和同一个聚类下的gt框之间的IOU,采用的距离公式如下:</p>
<p><img src="https://www.zhihu.com/equation?tex=d%28box%2Ccentroid%29%3D1-IOU%28box%2Ccentroid%29+%5C%5C" alt="[公式]"></p>
<ul>
<li>centroid为聚类时被选作中心的bounding box</li>
<li><p>box为其他的bounding box</p>
</li>
<li><p>对box进行K-means的步骤为：</p>
<ol>
<li>随机选取K个box作为初始anchor；</li>
<li>使用IOU度量，将每个box分配给与其距离最近的anchor；</li>
<li>计算每个簇中所有box宽和高的均值，更新anchor；</li>
<li>重复2、3步，直到anchor不再变化，或者达到了最大迭代次数。</li>
</ol>
</li>
</ul>
<h3 id="直接位置预测"><a href="#直接位置预测" class="headerlink" title="直接位置预测"></a>直接位置预测</h3><p><img src="https://pic1.zhimg.com/80/v2-85109b623daae191035f5c0fdbf4f960_720w.jpg" alt="img"></p>
<p>tx,ty,tw,th是预测值，cx和cy是grid cell左上角位置，pw和ph是anchor box的值，通过计算即可得到预测框在特征图上的位置，从而得到在原图的位置；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220516203403.png" alt></p>
<p>t0是预测值，进行σ变换后作为置信度的值。</p>
<p><strong>注：</strong>用IOU最大的去进行回归，Pr(object)的值是1，其余是0；</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>YOLOv2采用了一个新的特征提取主干 Darknet-19,包括19个卷积层,5个maxpooling层；</p>
<h3 id="特征融合"><a href="#特征融合" class="headerlink" title="特征融合"></a>特征融合</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220515155346.png" alt></p>
<h3 id="YOLO-v1和YOLO-v2输出对比"><a href="#YOLO-v1和YOLO-v2输出对比" class="headerlink" title="YOLO v1和YOLO v2输出对比"></a>YOLO v1和YOLO v2输出对比</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220516155929.png" alt></p>
<p>YOLOv2的输出是一个13 <em> 13 </em> 125的一个张量。</p>
<h3 id="多尺度训练"><a href="#多尺度训练" class="headerlink" title="多尺度训练"></a>多尺度训练</h3><p>训练尺度的大小必须为32的倍数，最小320，最大640；</p>
<p>使用多尺度训练时，然后只需要修改对最后检测层的处理就可以重新训练。</p>
<h3 id="anchor-box和bounding-box的区别"><a href="#anchor-box和bounding-box的区别" class="headerlink" title="anchor box和bounding box的区别"></a>anchor box和bounding box的区别</h3><ul>
<li>anchor box是静止的框，随着神经网络的训练是不变的；</li>
<li>anchor box只有宽高，不需要中心点(也可以理解为中心点为grid cell左上角坐标)</li>
<li>bounding box是动态的框，它是根据预测值偏移量(tx,ty,tw,th)和anchor box生成的；</li>
<li>在这里计算的是bounding box与GroundTruth之间的误差；</li>
<li>若设GroundTruth在anchor box的偏移量为(dx,dy,dw,dh)，那么误差为(tx,ty,tw,th)与(dx,dy,dw,dh)的误差；</li>
<li>详细看<a href="https://www.cxymm.net/article/shenkunchang1877/105648111">YOLO v2和V3 关于设置生成anchorbox，Boundingbox边框回归的个人理解</a></li>
</ul>
<h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><ul>
<li>第一阶段：就是先在ImageNet分类数据集上预训练Darknet-19，此时模型输入为 224*224 ，共训练160个epochs；</li>
<li>第二阶段：将网络的输入调整为 448*448 ，继续在ImageNet数据集上finetune分类模型，训练10个epochs，此时分类模型的top-1准确度为76.5%，而top-5准确度为93.3%；</li>
<li>第三个阶段：修改Darknet-19分类模型为检测模型，移除最后一个卷积层、global avgpooling层以及softmax层，并且新增了三个 3<em>3</em>1024卷积层，同时增加了一个passthrough层，最后使用 1<em>1 卷积层输出预测结果，输出的channels数为：**num_anchors\</em>(5+num_classes)** ，和训练采用的数据集有关系。由于anchors数为5，对于VOC数据集（20种分类对象）输出的channels数就是125。</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211130183457.PNG" alt></p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLO</tag>
      </tags>
  </entry>
  <entry>
    <title>面试[2022.4.25]</title>
    <url>/posts/21424/</url>
    <content><![CDATA[<ol>
<li><p>NMS的详细过程；</p>
<p><a href="https://blog.csdn.net/qq_33605633/article/details/119713351">答案</a></p>
</li>
<li><p>激活函数都有哪些，以及它们的值域；</p>
<p><a href="https://baijiahao.baidu.com/s?id=1711796979657939163">答案</a></p>
</li>
<li><p>梯度消失和梯度爆炸的原因；</p>
</li>
<li><p>BP算法；</p>
</li>
<li><p>对于平均池化层和最大池化层的BP算法的推导；</p>
</li>
<li><p>过拟合的损失函数会呈现一个什么样的状态；</p>
</li>
</ol>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220503170058.png" alt></p>
<p>在缺少有效预防欠拟合和过拟合措施的情况下，随着模型拟合能力的增强，错误率在训练集上逐渐减小，而在验证集上先减小后增大；当两者的误差率都较大时，处于欠拟合状态(high bias, low variance)；当验证集误差率达到最低点时，说明拟合效果最好，由最低点增大时，处与过拟合状态(high variance, low bias)。(参考于<a href="https://blog.csdn.net/txpp520/article/details/105347189">https://blog.csdn.net/txpp520/article/details/105347189</a>)</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测中常见指标</title>
    <url>/posts/13357/</url>
    <content><![CDATA[<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220503145055.png" alt></p>
<h3 id="查准率和查全率"><a href="#查准率和查全率" class="headerlink" title="查准率和查全率"></a>查准率和查全率</h3><p><strong>查准率</strong>：就是预测是真的中，实际是真的的比例；</p>
<p><strong>查全率</strong>：就是标签是真的中，预测是真的的比例；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">预测真</th>
<th style="text-align:center">预测假</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标签真</td>
<td style="text-align:center">TP</td>
<td style="text-align:center">FN</td>
</tr>
<tr>
<td style="text-align:center">标签假</td>
<td style="text-align:center">FP</td>
<td style="text-align:center">TN</td>
</tr>
</tbody>
</table>
</div>
<p>T/F：True/False；</p>
<p>P/N：Positive/Negative</p>
<p>Precision(查准率或精确率) = TP / (TP+FP)</p>
<p>Recall(查全率或召回率) = TP / (TP+FN)</p>
<h3 id="IOU"><a href="#IOU" class="headerlink" title="IOU"></a>IOU</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220503150922.png" alt></p>
<p>IOU就是预测框和真实框两则的交集和并集的比值；</p>
<h3 id="置信度"><a href="#置信度" class="headerlink" title="置信度"></a>置信度</h3><p>confidence表示它是一个物体的可能性有多大；</p>
<h3 id="AP和mAP"><a href="#AP和mAP" class="headerlink" title="AP和mAP"></a>AP和mAP</h3><p><strong>map指标综合衡量检测效果；</strong></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220503161029.png" alt></p>
<p>求AP值首先需要设定一个IOU阈值，按照置信度的大小对所有的预测框进行排序；</p>
<p>然后分别按照每个置信度的值为阈值求出P和R，有多少个预测框就有多少对P、R值(P、R值可能会相同)；</p>
<p>把P-R值绘制到P-R图像上面；</p>
<p>对PR曲线进行平滑处理，即对PR曲线上的每个点，Precision的值取该点右侧最大的Precision的值；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220503163101.png" style="zoom:50%;"></p>
<p>求出PR曲线平滑后围成图形的面积，即为<strong>AP</strong>值；</p>
<p>求出各个类的AP，然后求平均，即为mAP(通常来说AP是在单个类别下的，mAP是AP值在所有类别下的均值)；</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>常见概念解释</title>
    <url>/posts/9806/</url>
    <content><![CDATA[<ol>
<li><a href="https://blog.csdn.net/qq_33605633/article/details/119713351">NMS非极大值抑制</a></li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移学习模型</title>
    <url>/posts/60901/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,models,datasets</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据读取与预处理操作</span></span><br><span class="line">data_dir = <span class="string">&#x27;./flower_data/&#x27;</span></span><br><span class="line">train_dir = data_dir + <span class="string">&#x27;/train&#x27;</span></span><br><span class="line">valid_dir = data_dir + <span class="string">&#x27;/valid&#x27;</span></span><br><span class="line">num_classes = <span class="number">102</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 制作好数据源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据增强(Data Augmentation)</span></span><br><span class="line"><span class="comment"># 数据不够怎么办？如何更高效的利用数据？</span></span><br><span class="line"><span class="comment"># 对图像进行镜像，翻转，旋转，放大，缩小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 制作好数据源</span></span><br><span class="line"><span class="comment"># data_transforms中指定了所有图像预处理操作</span></span><br><span class="line"><span class="comment"># ImageFolder假设所有的文件按文件夹保存好，每个文件夹下面存同一类别的图片，文件夹的名字为分类的名字</span></span><br><span class="line">data_transfroms = &#123;</span><br><span class="line">    <span class="string">&#x27;train&#x27;</span>:transforms.Compose([ <span class="comment"># transforms.Compose()类用来组合多个torchvision.transforms操作。</span></span><br><span class="line">        transforms.RandomRotation(<span class="number">45</span>),<span class="comment"># 随机旋转，-45到45度之间随机选</span></span><br><span class="line">        transforms.CenterCrop(<span class="number">224</span>), <span class="comment">#从中心开始裁剪  留下224*224的图像区域   另外还有随机裁剪</span></span><br><span class="line">        transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>), <span class="comment"># 随机水平翻转，选择一个概率  做镜像</span></span><br><span class="line">        transforms.RandomVerticalFlip(p=<span class="number">0.5</span>), <span class="comment"># 随机垂直翻转   做镜像</span></span><br><span class="line">        transforms.ColorJitter(brightness=<span class="number">0.2</span>,contrast=<span class="number">0.1</span>,saturation=<span class="number">0.1</span>,hue=<span class="number">0.1</span>), <span class="comment"># 参数1为亮度，参数2为对比度，参数3为饱和度，参数4为色相</span></span><br><span class="line">        transforms.RandomGrayscale(p=<span class="number">0.025</span>), <span class="comment"># 概率转换成灰度率，3通道就是R=G=B</span></span><br><span class="line">        transforms.ToTensor(), <span class="comment"># ???归一化</span></span><br><span class="line">        <span class="comment"># PIL Image或numpy.ndarray(形状为HxWxC)数据范围是[0,255]到一个Torch.FloatTensor</span></span><br><span class="line"></span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>,<span class="number">0.456</span>,<span class="number">0.406</span>],[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>]) <span class="comment"># 均值，标准差</span></span><br><span class="line">        <span class="comment"># 为了使迁移学习效果更好，用人家模型的均值和标准差</span></span><br><span class="line">    ]),</span><br><span class="line">    <span class="comment"># 除了数据增强外，训练集和验证集的数据处理要一样</span></span><br><span class="line">    <span class="string">&#x27;valid&#x27;</span>:transforms.Compose([</span><br><span class="line">        transforms.Resize(<span class="number">256</span>), <span class="comment">#调整图片的大小，使图片</span></span><br><span class="line">        transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>,<span class="number">0.456</span>,<span class="number">0.406</span>],[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>]) <span class="comment"># 均值，标准差 和训练时参数设置一样</span></span><br><span class="line">        <span class="comment"># 因为这里是预测图像的结果，不需要考虑训练时的一些参数设置</span></span><br><span class="line">    ]),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Batch数据制作</span></span><br><span class="line">batch_size = <span class="number">8</span> <span class="comment">#根据内存适当的调整大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># datasets.ImageFolder(root,transform,...)</span></span><br><span class="line"><span class="comment"># root 图片存储的根路径 transform 图片进行的变换</span></span><br><span class="line"><span class="comment"># 返回值 self.classes：用一个list保存类别名称;...</span></span><br><span class="line">image_datasets = &#123;x: datasets.ImageFolder(os.path.join(data_dir,x),data_transfroms[x]) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;valid&#x27;</span>]&#125;</span><br><span class="line">dataloaders = &#123;x: torch.utils.data.DataLoader(image_datasets[x],batch_size=batch_size,shuffle=<span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;valid&#x27;</span>]&#125;</span><br><span class="line">dataset_sizes = &#123;x: <span class="built_in">len</span>(image_datasets[x]) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;valid&#x27;</span>]&#125;</span><br><span class="line">class_names = image_datasets[<span class="string">&#x27;train&#x27;</span>].classes</span><br><span class="line">print(class_names)</span><br><span class="line"><span class="comment"># print(dataset_sizes)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取标签对应的名字</span></span><br><span class="line"><span class="comment">#  with as 操作已经打开的文件对象（本身就是上下文管理器），无论期间是否抛出异常，都能保证 with as 语句执行完毕后自动关闭已经打开的文件。</span></span><br><span class="line"><span class="comment"># target 参数用于指定一个变量，该语句会将 expression 指定的结果保存到该变量中</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cat_to_name.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cat_to_name = json.load(f)  <span class="comment"># json.load读取文件类型，返回的数据类型是字典</span></span><br><span class="line">    print(cat_to_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示下数据</span></span><br><span class="line"><span class="comment"># 注意tensor的数据需要转化成numpy的格式，而且还需要还原回标准化的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">im_convert</span>(<span class="params">tensor</span>):</span></span><br><span class="line">    <span class="comment"># 展示数据</span></span><br><span class="line">    image = tensor.to(<span class="string">&quot;cpu&quot;</span>).clone().detach()</span><br><span class="line">    image = image.numpy().squeeze()</span><br><span class="line">    image = image.transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>) <span class="comment"># h,w,c     在tensor中c,h,w</span></span><br><span class="line">    image = image * np.array((<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>)) + np.array((<span class="number">0.485</span>,<span class="number">0.456</span>,<span class="number">0.406</span>)) <span class="comment"># 把数据还原回去</span></span><br><span class="line">    image = image.clip(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">12</span>))</span><br><span class="line"><span class="comment"># plt.figure设置画布的大小和背景   figsize:设置画布大小</span></span><br><span class="line">columns = <span class="number">4</span></span><br><span class="line">rows = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">dataiter = <span class="built_in">iter</span>(dataloaders[<span class="string">&#x27;train&#x27;</span>]) <span class="comment"># iter的输入是支持迭代的集合对象</span></span><br><span class="line">print(dataiter)</span><br><span class="line">inputs,classes = dataiter.<span class="built_in">next</span>()</span><br><span class="line">print(classes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(columns * rows):</span><br><span class="line">    <span class="comment"># add_subplot(rows, columns, idx) 将画布分成rows行，columns列，图像画在从左到右从上到下的第idx块</span></span><br><span class="line">    ax = fig.add_subplot(rows, columns, idx+<span class="number">1</span>, xticks=[], yticks=[])</span><br><span class="line">    ax.set_title(cat_to_name[<span class="built_in">str</span>(<span class="built_in">int</span>(class_names[classes[idx]]))])</span><br><span class="line">    plt.imshow(im_convert(inputs[idx]))</span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载models中提供的模型，并且直接用训练好的权重当做初试化参数</span></span><br><span class="line"><span class="comment"># 第一次执行需要下载，可能会比较慢</span></span><br><span class="line"></span><br><span class="line">model_name = <span class="string">&#x27;resnet&#x27;</span> <span class="comment"># 可选的比较多[&#x27;ResNet&#x27;,&#x27;alexnet&#x27;,&#x27;vgg&#x27;,&#x27;squeezenet&#x27;,&#x27;densenet&#x27;,&#x27;inception&#x27;]</span></span><br><span class="line"><span class="comment"># 是否用人家训练好的特征来做</span></span><br><span class="line">feature_extract = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 是否用GPU训练</span></span><br><span class="line">train_on_gpu = torch.cuda.is_available()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> train_on_gpu:</span><br><span class="line">    print(<span class="string">&#x27;GPU false&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;GPU True&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#torch.device包含一个设备类型（&#x27;cpu&#x27;或&#x27;cuda&#x27;设备类型）和可选的设备的序号</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="comment"># print(device)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置不更新的部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_parameter_requires_grad</span>(<span class="params">model, feature_extracting</span>):</span></span><br><span class="line">    <span class="keyword">if</span> feature_extracting:</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">            param.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">model_ft = models.resnet152()</span><br><span class="line"><span class="comment"># print(model_ft)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_model</span>(<span class="params">model_name,num_classes,feature_extract,use_pretrained=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="comment"># 选择合适的模型，不同模型的初始化方法稍微有点区别</span></span><br><span class="line">    model_ft = <span class="literal">None</span></span><br><span class="line">    input_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> model_name == <span class="string">&#x27;resnet&#x27;</span>:</span><br><span class="line">        model_ft = models.resnet152(pretrained=use_pretrained) <span class="comment"># pretrained为true 会下载训练好的模型</span></span><br><span class="line">        set_parameter_requires_grad(model_ft,feature_extract) <span class="comment"># 选择性的冻住哪些层</span></span><br><span class="line">        num_ftrs = model_ft.fc.in_features <span class="comment"># 用fc.in_features得到最后一层的输出，即下一层的输入</span></span><br><span class="line">        <span class="comment"># 重写fc层</span></span><br><span class="line">        <span class="comment"># softmax和logsoftmax</span></span><br><span class="line">        <span class="comment"># softmax是 该数求指数 / 所有数求指数的和</span></span><br><span class="line">        <span class="comment"># logsoftmax是 log(softmax) 把softmax的结果log一下</span></span><br><span class="line">        model_ft.fc = nn.Sequential(nn.Linear(num_ftrs,num_classes),nn.LogSoftmax(dim=<span class="number">1</span>))</span><br><span class="line">        input_size = <span class="number">224</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model_ft, input_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置哪些层需要训练</span></span><br><span class="line">model_ft, input_size = initialize_model(model_name,num_classes,feature_extract,use_pretrained=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># GPU计算</span></span><br><span class="line"><span class="comment"># 构造好的模型加入GPU</span></span><br><span class="line">model_ft = model_ft.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型保存</span></span><br><span class="line">filename = <span class="string">&#x27;checkpoint.pth&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否训练所有层</span></span><br><span class="line">params_to_update = model_ft.parameters()</span><br><span class="line">print(<span class="string">&#x27;Params to learn:&#x27;</span>)</span><br><span class="line"><span class="comment"># 这个if else是为了查看哪些参数是需要被训练的</span></span><br><span class="line"><span class="keyword">if</span> feature_extract:</span><br><span class="line">    params_to_update = []</span><br><span class="line">    <span class="keyword">for</span> name,param <span class="keyword">in</span> model_ft.named_parameters():</span><br><span class="line">        <span class="keyword">if</span> param.requires_grad == <span class="literal">True</span>:</span><br><span class="line">            params_to_update.append(param)</span><br><span class="line">            print(<span class="string">&quot;\t&quot;</span>,name)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> name,param <span class="keyword">in</span> model_ft.named_parameters():</span><br><span class="line">        <span class="keyword">if</span> param.requires_grad == <span class="literal">True</span>:</span><br><span class="line">            print(<span class="string">&quot;\t&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器设置</span></span><br><span class="line">optimizer_ft = optim.Adam(model_ft.parameters(),lr=<span class="number">1e-2</span>)</span><br><span class="line">scheduler = optim.lr_scheduler.StepLR(optimizer_ft,step_size=<span class="number">7</span>,gamma=<span class="number">0.1</span>) <span class="comment"># 学习率每7个epoch衰减成原来的1/10</span></span><br><span class="line"><span class="comment"># 最后一层已经LogSoftmax()了，所以不能nn.CrossEntropyLoss()来计算了，nn.CrossEntropyLoss()相当于logSoftmax()和nn.NLLLoss()整合</span></span><br><span class="line">criterion = nn.NLLLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span>(<span class="params">model, dataloaders, criterion, optimizer, num_epochs=<span class="number">10</span>, is_inception=<span class="literal">False</span>, filename=filename</span>):</span></span><br><span class="line">    since = time.time()</span><br><span class="line">    best_acc = <span class="number">0</span> <span class="comment"># 最好的准确率</span></span><br><span class="line">    <span class="comment"># ！！！！不是保存最后一个模型，而是保存准确率较高的模型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练前把模型加入GPU</span></span><br><span class="line">    model.to(device)</span><br><span class="line"></span><br><span class="line">    val_acc_history = []</span><br><span class="line">    train_acc_history = []</span><br><span class="line">    train_losses = []</span><br><span class="line">    valid_losses = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># optimizer.param_groups： 是长度为2的list，其中的元素是2个字典；</span></span><br><span class="line">    <span class="comment"># optimizer.param_groups[0]： 长度为6的字典，包括[‘amsgrad’, ‘params’, ‘lr’, ‘betas’, ‘weight_decay’, ‘eps’]这6个参数；</span></span><br><span class="line">    <span class="comment"># optimizer.param_groups[1]： 好像是表示优化器的状态的一个字典；</span></span><br><span class="line">    LRs = [optimizer.param_groups[<span class="number">0</span>][<span class="string">&#x27;lr&#x27;</span>]] <span class="comment">#学习率数组</span></span><br><span class="line">    <span class="comment"># copy.deepcopy() python中的函数进行深拷贝</span></span><br><span class="line">    best_model_wts = copy.deepcopy(model.state_dict())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        print(<span class="string">&quot;Epoch &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch,num_epochs-<span class="number">1</span>))</span><br><span class="line">        print(<span class="string">&#x27;-&#x27;</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练和验证</span></span><br><span class="line">        <span class="keyword">for</span> phase <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;valid&#x27;</span>]:</span><br><span class="line">            <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                model.train() <span class="comment"># 训练</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                model.<span class="built_in">eval</span>() <span class="comment"># 验证</span></span><br><span class="line"></span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line">            running_corrects = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 把数据都取个遍</span></span><br><span class="line">            <span class="keyword">for</span> inputs,labels <span class="keyword">in</span> dataloaders[phase]:</span><br><span class="line">                <span class="comment"># 把训练的数据加入GPU</span></span><br><span class="line">                inputs = inputs.to(device)</span><br><span class="line">                labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 清零</span></span><br><span class="line">                optimizer.zero_grad()</span><br><span class="line">                <span class="comment"># 只有训练的时候计算和更新梯度</span></span><br><span class="line">                    <span class="comment"># set_grad_enabled  用于设置梯度计算打开或关闭状态的上下文管理器.</span></span><br><span class="line">                <span class="keyword">with</span> torch.set_grad_enabled(phase == <span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">                    <span class="keyword">if</span> is_inception <span class="keyword">and</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                        outputs, aux_outputs = model(inputs)</span><br><span class="line">                        loss1 = criterion(outputs,labels)</span><br><span class="line">                        loss2 = criterion(aux_outputs,labels)</span><br><span class="line">                        loss = loss1 + <span class="number">0.4</span>*loss2</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        outputs = model(inputs)</span><br><span class="line">                        loss = criterion(outputs,labels)</span><br><span class="line">                        <span class="comment"># print(type(outputs))</span></span><br><span class="line">                    _,preds = torch.<span class="built_in">max</span>(outputs,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 训练阶段更新权重</span></span><br><span class="line">                    <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                        loss.backward()</span><br><span class="line">                        optimizer.step()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算损失</span></span><br><span class="line">                running_loss +=loss.item() * inputs.size(<span class="number">0</span>)</span><br><span class="line">                running_corrects += torch.<span class="built_in">sum</span>(preds == labels.data)</span><br><span class="line"></span><br><span class="line">            epoch_loss = running_loss / <span class="built_in">len</span>(dataloaders[phase].dataset)</span><br><span class="line">            epoch_acc = running_corrects.double() / <span class="built_in">len</span>(dataloaders[phase].dataset)</span><br><span class="line"></span><br><span class="line">            time_elapsed = time.time() - since</span><br><span class="line">            print(<span class="string">&#x27;Time elapsed &#123;:.0f&#125;m &#123;:.0f&#125;s&#x27;</span>.<span class="built_in">format</span>(time_elapsed // <span class="number">60</span>, time_elapsed % <span class="number">60</span>))</span><br><span class="line">            print(<span class="string">&#x27;&#123;&#125; Loss: &#123;:.4f&#125; Acc: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(phase, epoch_loss, epoch_acc))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 得到最好那次的模型</span></span><br><span class="line">            <span class="keyword">if</span> phase == <span class="string">&#x27;valid&#x27;</span> <span class="keyword">and</span> epoch_acc &gt; best_acc:</span><br><span class="line">                best_acc = epoch_acc</span><br><span class="line">                best_model_wts = copy.deepcopy(model.state_dict())</span><br><span class="line">                <span class="comment"># pytorch中model.parameters()和model.state_dict()使用时的区别</span></span><br><span class="line">                <span class="comment"># model.parameters()方法返回的是一个生成器generator，里面只有模型的参数，而没有对应的网络层名称；</span></span><br><span class="line">                <span class="comment"># 并且 如果有些层的参数没有被训练，那么它只保存那些被训练的参数</span></span><br><span class="line">                <span class="comment"># model.state_dict() 返回的则是一个字典 &#123;key:value&#125;，key 是网络层名称，value 则是该层的参数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># state_dict()是一个状态字典,⼀个简单的python的字典对象,将每⼀层与它的对应参数建⽴映射关系</span></span><br><span class="line">                state = &#123;</span><br><span class="line">                    <span class="string">&#x27;state_dict&#x27;</span>: model.state_dict(),</span><br><span class="line">                    <span class="string">&#x27;best_acc&#x27;</span>: best_acc,</span><br><span class="line">                    <span class="comment"># 优化器参数：有时保存模型的参数需要稍后接着训练，那么就必须保存优化器的状态和其所使用的超参数</span></span><br><span class="line">                    <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict(), <span class="comment"># 包含了优化器的状态，以及被使用的超参数</span></span><br><span class="line">                &#125;</span><br><span class="line">                torch.save(state, filename)</span><br><span class="line">            <span class="keyword">if</span> phase == <span class="string">&#x27;valid&#x27;</span>:</span><br><span class="line">                val_acc_history.append(epoch_acc)</span><br><span class="line">                valid_losses.append(epoch_loss)</span><br><span class="line">                <span class="comment"># scheduler.step（）按照Pytorch的定义是用来更新优化器的学习率的，一般是按照epoch为单位进行更换，即多少个epoch后更换一次学习率</span></span><br><span class="line">                <span class="comment"># ???epoch_loss这个参数有什么意义呢</span></span><br><span class="line">                scheduler.step(epoch_loss)</span><br><span class="line">            <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                train_acc_history.append(epoch_acc)</span><br><span class="line">                train_losses.append(epoch_loss)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&#x27;Optimizer learning rate : &#123;:.7f&#125;&#x27;</span>.<span class="built_in">format</span>(optimizer.param_groups[<span class="number">0</span>][<span class="string">&#x27;lr&#x27;</span>]))</span><br><span class="line">        LRs.append(optimizer.param_groups[<span class="number">0</span>][<span class="string">&#x27;lr&#x27;</span>])</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line">    time_elapsed = time.time() - since</span><br><span class="line">    print(<span class="string">&#x27;Training complete in &#123;:.0f&#125;m &#123;:.0f&#125;s&#x27;</span>.<span class="built_in">format</span>(time_elapsed // <span class="number">60</span>, time_elapsed % <span class="number">60</span>))</span><br><span class="line">    print(<span class="string">&#x27;Best val Acc: &#123;:4f&#125;&#x27;</span>.<span class="built_in">format</span>(best_acc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练完后用最好的一次当做模型最终的结果</span></span><br><span class="line">    model.load_state_dict(best_model_wts)</span><br><span class="line">    <span class="keyword">return</span> model, val_acc_history, train_acc_history, valid_losses, train_losses, LRs</span><br><span class="line"></span><br><span class="line">model_ft, val_acc_history, train_acc_history, valid_losses, train_losses, LRs  = train_model(model_ft, dataloaders, criterion, optimizer_ft, num_epochs=<span class="number">10</span>, is_inception=(model_name==<span class="string">&quot;inception&quot;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归模型</title>
    <url>/posts/21594/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line">x_values = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>)]</span><br><span class="line">x_train = np.array(x_values, dtype=np.float32)</span><br><span class="line">x_train = x_train.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">print(x_train.shape)</span><br><span class="line"></span><br><span class="line">y_values = [<span class="number">2</span> * i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> x_values]</span><br><span class="line">y_train = np.array(y_values, dtype=np.float32)</span><br><span class="line">y_train = y_train.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">print(y_train.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性回归模型(其实线性回归就是一个不加激活函数的全连接层)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegressionModel</span>(<span class="params">nn.Module</span>):</span> <span class="comment"># nn.Module父类</span></span><br><span class="line">    <span class="comment"># 前面介绍了如何自定义一个模型——通过继承nn.Module类来实现，</span></span><br><span class="line">    <span class="comment"># 在__init__构造函数中申明各个层的定义，在forward中实现层之间的连接关系，实际上就是前向传播的过程。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_dim, output_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LinearRegressionModel, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(input_dim, output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化一个对象中传入对应的参数就可以自动调用forward函数,是在进行前向传播时调用的，而不是在__init__后就直接调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># input_dim和output_dim是输入数据的维度和输出数据的维度</span></span><br><span class="line">input_dim = <span class="number">1</span></span><br><span class="line">output_dim = <span class="number">1</span></span><br><span class="line">model = LinearRegressionModel(input_dim, output_dim)</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) <span class="comment"># optimizer 优化器</span></span><br><span class="line"><span class="comment"># 损失函数一般看任务来说吧  分类任务一般都是交叉熵，回归任务一般条件下是MSE</span></span><br><span class="line">criterion = nn.MSELoss()    <span class="comment"># criterion 标准</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    epoch += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 注意转换成tensor</span></span><br><span class="line">    inputs = torch.from_numpy(x_train)</span><br><span class="line">    labels = torch.from_numpy(y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 梯度要清零每一次迭代</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    outputs = model(inputs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新权重参数</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&quot;epoch &#123;&#125;,loss &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, loss.item()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用模型去预测结果</span></span><br><span class="line">predicted = model(torch.from_numpy(x_train).requires_grad_()).data.numpy()</span><br><span class="line">print(predicted)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>小王子-玫瑰片段</title>
    <url>/posts/31083/</url>
    <content><![CDATA[<p>小王子遇见了一只狐狸。狐狸告诉小王子，“如果你驯服我，我们便属于彼此。”</p>
<p>小王子每天在同一个时间来，渐渐地他驯服了狐狸。</p>
<p>可是小王子却要离开了。</p>
<p>在小王子要离开的时候，狐狸让他再去看一眼那五千多朵玫瑰。</p>
<p>小王子回到了玫瑰园。</p>
<p>他对玫瑰们说，“你们很美丽，但也很空虚，不会有人为你们去死。当然，寻常的路人会认为我的玫瑰花和你们差不多。但她比你们全部加起来还重要，因为我给她浇过水。因为我给她盖过玻璃罩。因为我为她挡过风。因为我为她消灭过毛毛虫。因为我倾听过她的抱怨和吹嘘，甚至有时候也倾听她的沉默。因为她是我的玫瑰。“</p>
<p>小王子最后与狐狸告了别。</p>
<p><strong>狐狸告诉了小王子一个秘密：”你的玫瑰之所以如此宝贵，是因为你曾为她付出的时间。“</strong></p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv1</title>
    <url>/posts/1018/</url>
    <content><![CDATA[<h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><ol>
<li><p>图片处理成大小为448*448，喂给神经网络模型；</p>
</li>
<li><p>经过神经网络后，会输出7 <em> 7 </em> 30大小的矩阵；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220503124946.png" alt></p>
</li>
<li><p>30是指每个grid cell可以预测出两个bbox,每个bbox会有四个参数来表示这个bbox具体的位置和大小，每个框还有一个confidence score参数，共10个参数；另外，每个gird cell可以预测出20个类别的概率，共20个参数；共30个参数；<br>(x1,y1,w1,h1,confidence1,x2,y2,h2,w2,confidence2,…)</p>
</li>
<li><p>(x, y)坐标代表bbox的中心相对于网格单元的边界；w,h是相对于整个图像的预测。</p>
</li>
<li><p>一个标记框的中心点落在哪个grid cell中，就让哪个gird cell的一个bbox(IOU较大)去拟合这个框，并且这个grid cell输出的类别也应该是正确的类别；</p>
</li>
<li><p>每个grid cell只能预测出一个物体，49个grid cell只能预测出49个物体；这也是YOLO v1在预测小目标和密集目标较差的原因；</p>
</li>
<li><p>在训练过程中confidence score参数是 IOU和Pr(Object)的乘积，Pr(Object)是指bbox是否是被选中的预测框的概率，非0即1；IOU是某个gird cell的bbox和打标的真是框的面积交并比；</p>
</li>
<li><p>每个grid cell预测出的两个bbox,则会产生两个IOU；若该grid cell有预测物体，则选择IOU较大的bbox去拟合；若该grid cell没有预测物体，则confidence score尽可能的小，接近于0；</p>
</li>
<li><p>最后一层预测类概率和边界框坐标。我们根据图像的宽度和高度使边界框的宽度和高度标准化，使它们在0和1之间。我们将边界盒和坐标参数化，使其成为特定网格单元格位置的偏移量，因此它们也被限定在0和1之间。</p>
</li>
<li><p>损失函数的设计：</p>
</li>
</ol>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211118183146.PNG" alt></p>
<ul>
<li>带^的数据是真实值；</li>
<li>λcoord和λnoobj的作用是为了平衡负样本和正样本比例不均衡的问题；</li>
<li>Ci的标签值非0即1；</li>
<li>pi的标签值非0即1；</li>
</ul>
<ol>
<li>对于中心点的损失直接用了均方误差，但是对于宽高为什么用了平方根呢？</li>
</ol>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211118191016.png" alt></p>
<p>上图中，蓝色为bounding box，红色框为真实标注，如果W和h没有平方根的话，那么bounding box跟两个真实标注的位置loss是相同的。但是从面积看来B框是A框的25倍，C框是B框的81/25倍。B框跟A框的大小偏差更大，所以不应该有相同的loss。<br>如果W和h加上平方根，那么B对A的位置loss约为3.06，B对C的位置loss约为1.17，B对A的位置loss的值更大，这更加符合我们的实际判断。所以，算法对位置损失中的宽高损失加上了平方根。(参考于<a href="https://blog.csdn.net/x454045816/article/details/107527326/">https://blog.csdn.net/x454045816/article/details/107527326/</a>)<br><strong>因为平方根对小数据敏感，对大数据不敏感，比如对于根号x，一阶导数随着x的增大而减小</strong></p>
<h3 id="预测阶段"><a href="#预测阶段" class="headerlink" title="预测阶段"></a>预测阶段</h3><ol>
<li><p>直接把图片交给神经网络即可输出结果；</p>
</li>
<li><p>采用<a href="https://blog.csdn.net/qq_33605633/article/details/119713351">NMS非极大值抑制</a>的方法，使低置信度的预测不显示出来；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image20220503125906.png" alt></p>
</li>
<li><p>并不是所有的gird cell的都可以预测出物体的位置；</p>
</li>
</ol>
<p>(参考于<a href="https://blog.csdn.net/weixin_48200452/article/details/116453893">https://blog.csdn.net/weixin_48200452/article/details/116453893</a>)</p>
<h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf">YOLO v1</a></p>
<p><a href="https://github.com/abeardear/pytorch-YOLO-v1">代码</a></p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>YOLO</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy.transpose手算</title>
    <url>/posts/undefined/</url>
    <content><![CDATA[<p>原理解析请看：<a href="https://blog.csdn.net/u012762410/article/details/78912667">点击1</a> <a href="https://www.freesion.com/article/149821286/">点击2</a></p>
<h5 id="当是二维时"><a href="#当是二维时" class="headerlink" title="当是二维时"></a>当是二维时</h5><p>直接对矩阵进行转置；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">transpose后</span><br><span class="line"></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<h5 id="当是三维时"><a href="#当是三维时" class="headerlink" title="当是三维时"></a>当是三维时</h5><p>交换x,y时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">            [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line">            </span><br><span class="line">           [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">            [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line">            </span><br><span class="line">transpose后</span><br><span class="line"></span><br><span class="line">A = array([[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>],</span><br><span class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]]])</span><br><span class="line"><span class="comment"># 可以直接把三维数组看成二维数组，把一个一维数组看成一个数，继续使用二维数组转置的方式即可；</span></span><br></pre></td></tr></table></figure>
<p>np.transpose(img, (1, 0, 2))操作，可以将图像逆时针翻转90度</p>
]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Pytorch-CIFAR-10数据集下载问题</title>
    <url>/posts/20203/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>错误：[Errno socket error] [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>全局取消证书验证（当项目对安全性问题不太重视时，推荐使用，可以全局取消证书的验证，简易方便）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>pytorch</tag>
        <tag>CIFAR10</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉识别</title>
    <url>/posts/49853/</url>
    <content><![CDATA[<h3 id="视觉识别任务"><a href="#视觉识别任务" class="headerlink" title="视觉识别任务"></a>视觉识别任务</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011183222.png" alt></p>
<ul>
<li>分类：不考虑空间的位置；</li>
<li>语义分割：给我一个图像，告诉我图像上每一像素是什么语义；</li>
<li>目标检测：图像上某个区域是什么类别(是目标还是背景，是目标的话是什么标签)</li>
<li>实例分割：在同一个图像中，同一类别不同物品显示不同的颜色，即若一个图像中有两个猫，它会用不同的颜色表示两只猫；</li>
</ul>
<p>实例分割与语义分割不同的是：语义分割只区分同一种类，不区分同一种类中的不同。</p>
<h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>给每个像素分配类别标签不区分实例，只考虑像素类别。</p>
<h4 id="语义分割思路"><a href="#语义分割思路" class="headerlink" title="语义分割思路"></a>语义分割思路</h4><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011184146.png" alt></p>
<p>具体过程：在一张图片上，通过滑动窗口的方式对每个点取周围的区域进行分类判断；</p>
<p>存在的问题：效率太低；</p>
<h5 id="全卷积"><a href="#全卷积" class="headerlink" title="全卷积"></a>全卷积</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011184526.png" alt></p>
<p>C的大小为类别个数；</p>
<p>具体过程：给输入的特征图增加padding，使其保持原有大小；输出为C <em> H </em> w的特征图，可以看成H <em> W个C维向量，每个C维向量只有一个类别；并且把标答也做成C </em> H * W，利用交叉熵进行比较，并进行反向传播；</p>
<p>但同时也存在问题；</p>
<h5 id="改进的全卷积"><a href="#改进的全卷积" class="headerlink" title="改进的全卷积"></a>改进的全卷积</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011185622.png" alt></p>
<h6 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h6><p>下采样可以通过padding或增大步长的方式实现；</p>
<h6 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h6><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011190009.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011190115.png" alt></p>
<p>把1,2,3,4放到5,6,7,8的位置；</p>
<h6 id="转置卷积"><a href="#转置卷积" class="headerlink" title="转置卷积"></a>转置卷积</h6><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011191630.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211011190836.png" alt></p>
<p>x,y,z是三个参数；左右两图的两组x,y,z参数是不同的；</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013164717.png" alt></p>
<ul>
<li>传统的，在上采样过程中为了防止信息的丢失，直接把下采样过程中对应的特征图和上采样过程中对应的特征图拼接起来；</li>
<li>最优的，先把下采样过程中得到的特征图经过卷积进行卷积，然后再拼接起来，保证正向的一些信息流能够传递过来；</li>
</ul>
<h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>不光告诉我们图像中有什么目标，还要告诉我们它在什么位置；</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在倒数第二层的全连接层上分别接上分类器和确定位置的神经网络；</p>
<p>当做目标定位这种网络时，找到一个预先训练好的模型，然后直接把它分类，然后在这个训练的基础上，训练倒数第二层与定位层直接连接的参数，让它的总损失降到最低；</p>
<p>在实际的训练过程中可以这样，先训练好分类，然后所有参数不变去训练定位层的参数，然后再把所有参数都打开进行微调，使总损失下降；</p>
<h4 id="损失值"><a href="#损失值" class="headerlink" title="损失值"></a>损失值</h4><p>因为有分类和定位，所有又称多任务损失；</p>
<p>分类的损失很容易计算，那么定位的损失如何计算呢？</p>
<p>x,y,h,w相差的平方和。</p>
<p>在计算两个损失和时，可以设置权重，来倾向于哪个更拟合正确；</p>
<h4 id="多目标检测"><a href="#多目标检测" class="headerlink" title="多目标检测"></a>多目标检测</h4><p>当多个目标时，就难以知道标答的计算，采用单目标分类定位的方法是不可行的；只有当目标个数确定时，才能用单目标这种方法进行；</p>
<p>即因为不知道目标的个数，就难以确定输出的维度；</p>
<h5 id="方法1：滑动窗口"><a href="#方法1：滑动窗口" class="headerlink" title="方法1：滑动窗口"></a>方法1：滑动窗口</h5><p>存在的问题：CNN需要对图像中所有可能的区域（不同 位置、尺寸、长宽比）进行分类，计算量巨大！</p>
<h5 id="方法2：R-CNN"><a href="#方法2：R-CNN" class="headerlink" title="方法2：R-CNN"></a>方法2：R-CNN</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013182827.png" alt></p>
<ul>
<li>找出所有潜在可能包含目标的区域；</li>
<li>运行速度需要相对较快；</li>
</ul>
<p>利用区域建议方法产生感兴趣的区域，并对该区域进行缩放到224 <em> 224，因为输入要求是224 </em> 224，然后再把缩放后的图像进行特征提取；随后进行Bbox reg进行坐标回归和使用支持向量机对区域进行分类；</p>
<p>通过Bbox reg回归选取和实际的误差，调节选取窗口的参数，解决了选取区域不准确的问题；</p>
<p>存在的问题：计算效率低下；</p>
<p>解决方法：在特征图上进行区域扣取；</p>
<h5 id="方法3：Fast-R-CNN"><a href="#方法3：Fast-R-CNN" class="headerlink" title="方法3：Fast R-CNN"></a>方法3：Fast R-CNN</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013183112.png" alt></p>
<h6 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h6><p>先对整图进行卷积操作，然后再进行区域裁剪和缩放特征；</p>
<p>要保证裁剪和缩放都可导，整个网络才能训练。</p>
<h6 id="区域裁剪-RoI-Pool"><a href="#区域裁剪-RoI-Pool" class="headerlink" title="区域裁剪: RoI Pool"></a>区域裁剪: RoI Pool</h6><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013183741.png" alt></p>
<h6 id="区域裁剪-RoI-Align"><a href="#区域裁剪-RoI-Align" class="headerlink" title="区域裁剪: RoI Align"></a>区域裁剪: RoI Align</h6><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013184053.png" alt></p>
<p>与Rol Pool相比，保持映射过来的区域，平均选取四个点，进行计算该点的值，再采用最大池化的方式进行提取；</p>
<p>如何计算选点处的值？</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013184225.png" alt></p>
<h5 id="方法4：Faster-R-CNN"><a href="#方法4：Faster-R-CNN" class="headerlink" title="方法4：Faster R-CNN"></a>方法4：Faster R-CNN</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013185320.png" alt></p>
<h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>在中间特征层后加入区域建议网络RPN( Region Proposal Network) 产生候选区域，其他部分保持与Fast R-CNN一致，即 扣取每个候选区域的特征，然后对其进行分类。</p>
<h6 id="区域建议（Region-Proposal-Network）"><a href="#区域建议（Region-Proposal-Network）" class="headerlink" title="区域建议（Region Proposal Network）"></a>区域建议（Region Proposal Network）</h6><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013190034.png" alt></p>
<p>对每一个像素都要在它外面圈一个框，这个框的分类是什么，这代表这个位置的分类就是什么(是不是目标)；</p>
<p>问题：框选取多大，框长什么样？</p>
<p>在编程的时候选取的都是固定的区域，但是可以通过回归出来和真正需要选择区域的偏差量，调整区域框；</p>
<p>4k的4：每个像素回归4个数字；</p>
<p>对于选取的K <em> 20 </em> 15 的边框，选取最合适的前300个边框进行目标检测；</p>
<h6 id="四种损失"><a href="#四种损失" class="headerlink" title="四种损失"></a>四种损失</h6><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013190326.png" alt></p>
<p>RPN分类损失只是判断该区域是不是目标；</p>
<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><p><img src="/C:/Users\RomanticQq\AppData\Roaming\Typora\typora-user-images\image-20211013212211838.png" alt="image-20211013212211838"></p>
<p>整个训练过程：先对整个图像进行卷积，得到特征图，然后分别对每个像素点进行区域划分回归，选择就有可能是目标区域的300个区域进行区域裁剪，然后再进行分类和区域定位。</p>
<p><img src="/C:/Users\RomanticQq\AppData\Roaming\Typora\typora-user-images\image-20211013212736996.png" alt="image-20211013212736996"></p>
<p>YOLO是速度比较快的，虽然可能精度上没有Faster R-CNN高，但是性价比是比较高的；</p>
<h6 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h6><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013213651.png" alt></p>
<h4 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211013213815.png" alt></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>经典网络分析</title>
    <url>/posts/13634/</url>
    <content><![CDATA[<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003152950.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003153020.png" alt></p>
<h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p><em>AlexNet——验证了深度卷积神经网络的高效性</em></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003153124.png" alt></p>
<h4 id="主体贡献"><a href="#主体贡献" class="headerlink" title="主体贡献"></a>主体贡献</h4><ol>
<li>提出了一种卷积层加全连接层的卷积神经网络结构； </li>
<li>首次使用ReLU函数做为神经网络的激活函数； </li>
<li>首次提出Dropout正则化来控制过拟合 ；</li>
<li>使用加入动量的小批量梯度下降算法加速了训练过程的收敛；</li>
<li>使用数据增强策略极大地抑制了训练过程的过拟合； </li>
<li>利用了GPU的并行计算能力，加速了网络的训练与推断；</li>
</ol>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003153205.png" alt></p>
<p>NORM：批量相应归一化层；(现在基本不用了，因为它的性能在更深的网络里不太明显，计算量又有点大)</p>
<p>Max POOL：池化层；</p>
<p>AlexNet是8层神经网络结构，池化层和归一化层在计算神经网络的层数时不参与计算；</p>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>第一个卷积层的输入是经过去均值操作 后的数据，即原始向量—均值向量，再输入到神经网络里面；</p>
<p>去均值的作用？</p>
<p>我们在分类任务中，均值向量是没有实际意义的，在向量比较时，绝对值是没有意义的，比较的相对值。去均值是为了保留自己的相对值，这样也会更加有利于计算。</p>
<h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>3个池化层的卷积核大小3 * 3，步长为2；</p>
<p>这里是重叠池化，重叠有利于对抗过拟合，但是一般还是采用2*2的卷积核，步长为2；</p>
<p>池化层的作用：降低特征图尺寸，对抗轻微的目标偏移带来的影响；</p>
<p>轻微的目标偏移：比如在一个卷积核中最大值为8，最大池化后是8；但当这个8跑到这个卷积核中别的位置时，池化后的结果还是为8；因此能够对抗轻微的目标偏移带来的影响。</p>
<h4 id="局部相应归一化层"><a href="#局部相应归一化层" class="headerlink" title="局部相应归一化层"></a>局部相应归一化层</h4><p>目前基本不用了；</p>
<p>后来的研究表明： 更深的网络中该层 对分类性能的提升 效果并不明显，且 会增加计算量与存 储空间。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>对局部神经元的活动创建竞争机制； 、</li>
<li>响应比较大的值变得相对更大； </li>
<li>抑制其他反馈较小的神经元；</li>
<li>增强模型的泛化能力；</li>
</ul>
<h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>MAX POOL3的输出：特征响应图组，大小为6 <em> 6 </em> 256；</p>
<p>把MAX POOL3的输出打平成9216（6 <em> 6 </em> 256）维的向量，交给全连接层；</p>
<h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><ul>
<li>用于提取图像特征的卷积层以及用于分类的全连接层是同时学习的； </li>
<li>卷积层与全连接层在学习过程中会相互影响、相互促进；</li>
</ul>
<p>卷积层和全连接层是一起训练的，被训练的梯度是可以回传的；</p>
<h4 id="重要技巧"><a href="#重要技巧" class="headerlink" title="重要技巧"></a>重要技巧</h4><ul>
<li>Dropout策略防止过拟合； </li>
<li>使用加入动量的随机梯度下降算法，加速收敛； </li>
<li>验证集损失不下降时，手动降低10倍的学习率； </li>
<li>采用样本增强策略增加训练样本数量，防止过拟合； </li>
<li>集成多个模型，进一步提高精度(同时训练多个模型)；</li>
</ul>
<h4 id="AlexNet卷积层在做什么"><a href="#AlexNet卷积层在做什么" class="headerlink" title="AlexNet卷积层在做什么"></a>AlexNet卷积层在做什么</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003152829.png" alt></p>
<p>把AlexNet卷积层看作是一个卷积层，输入227 <em> 227 </em> 3，输出6 <em> 6 </em> 256，相当于有256个卷积核，获得256个特征响应图，把256个特征响应图拉成向量；</p>
<p>特征响应图某点处较亮，说明该亮处含有该卷积核的特征；</p>
<h3 id="ZFNet"><a href="#ZFNet" class="headerlink" title="ZFNet"></a>ZFNet</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003205744.png" alt></p>
<h4 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003210036.png" alt></p>
<h4 id="主要改进"><a href="#主要改进" class="headerlink" title="主要改进"></a>主要改进</h4><ul>
<li>将第一个卷积层的卷积核大小改为了7×7；(不要一次卷积就丢掉细颗粒度的东西)</li>
<li>将第一、第二个卷积层的卷积步长都设置为2；(缓慢给图像降维)</li>
<li>增加了第三、第四个卷积层的卷积核个数；(第三层、第四层有语义信息了，增加了神经元即增加模板信息，仅仅靠现有的模板数不足以存储信息)</li>
</ul>
<h4 id="AlexNet与ZFNet的对比"><a href="#AlexNet与ZFNet的对比" class="headerlink" title="AlexNet与ZFNet的对比"></a>AlexNet与ZFNet的对比</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003213738.png" alt></p>
<h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003210609.png" alt></p>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003211407.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003212318.png" alt></p>
<h4 id="VGG的输入"><a href="#VGG的输入" class="headerlink" title="VGG的输入"></a>VGG的输入</h4><p>VGG的输入与AlexNet和ZFNet是不同的，它是先把所有的R、G、B的均值求出来，然后再进行去均值的操作。</p>
<h4 id="VGG16-VS-VGG19"><a href="#VGG16-VS-VGG19" class="headerlink" title="VGG16 VS VGG19"></a>VGG16 VS VGG19</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211003211538.png" alt></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h5 id="问题1：小卷积核有哪些优势？"><a href="#问题1：小卷积核有哪些优势？" class="headerlink" title="问题1：小卷积核有哪些优势？"></a>问题1：小卷积核有哪些优势？</h5><p>多个小尺寸卷积核串联可以得到与大尺寸卷积核相同的感受野； </p>
<p>使用小卷积核串联构建的网络深度更深、非线性更强、参数也更少。</p>
<p>注：2个3 <em> 3卷积核的感受野相当于1个5 </em> 5卷积核的感受野；这两方式虽然感受野相同，但是最后获取的结果可能是不同的。</p>
<h5 id="问题2：：为什么VGG网络前四段里，每经过一次池化操作，卷积核个数就增加一倍？"><a href="#问题2：：为什么VGG网络前四段里，每经过一次池化操作，卷积核个数就增加一倍？" class="headerlink" title="问题2：：为什么VGG网络前四段里，每经过一次池化操作，卷积核个数就增加一倍？"></a>问题2：：为什么VGG网络前四段里，每经过一次池化操作，卷积核个数就增加一倍？</h5><ol>
<li><p>池化操作可以减小特征图尺寸，降低显存占用；</p>
</li>
<li><p>增加卷积核个数有助于学习更多的结构特征，但会增加网络参数数量以及内存消耗；</p>
</li>
<li><p>一减一增的设计平衡了识别精度与存储、计算开销；</p>
<p><em>最终还是提升了性能</em></p>
</li>
</ol>
<h5 id="问题3：为什么卷积核个数增加到512后就不再增加了？"><a href="#问题3：为什么卷积核个数增加到512后就不再增加了？" class="headerlink" title="问题3：为什么卷积核个数增加到512后就不再增加了？"></a>问题3：为什么卷积核个数增加到512后就不再增加了？</h5><ol>
<li>第一个全连接层含102M参数，占总参数个数的74%；</li>
<li>这一层的参数个数是特征图的尺寸与个数的乘积； </li>
<li>参数过多容易过拟合，且不易被训练；</li>
</ol>
<p>注：第一层全连接层的输入为7 <em> 7 </em> 512维的向量，则这一层需要的参数为102M(7 <em> 7 </em> 512 * 4096)参数;</p>
<p>若继续增加卷积核个数，那么第一层全连接层参数会更多，如为1024个卷积核，那么第一层全连接层参数将为200M，那样模型将会很难被训练；因此不是不想增加，而是增加不了。</p>
<h3 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211004161701.png" alt></p>
<h4 id="GoogleNet的结构"><a href="#GoogleNet的结构" class="headerlink" title="GoogleNet的结构"></a>GoogleNet的结构</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211004162104.jpg" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211004192544.png" alt></p>
<h4 id="GoogleNet的创新点"><a href="#GoogleNet的创新点" class="headerlink" title="GoogleNet的创新点"></a>GoogleNet的创新点</h4><ul>
<li>提出了一种Inception结构，它能保留输入信号中的更多特征信息；</li>
<li>去掉了AlexNet的前两个全连接层，并采用了平均池化，这一设计使得 GoogLeNet只有500万参数，比AlexNet少了12倍；</li>
<li>在网络的中部引入了辅助分类器，克服了训练过程中的梯度消失问题；</li>
</ul>
<p>从AlexNet等一些经典的神经网络中可知参数极大多数来源于与最后一层卷积层相连接的第一层全连接层，当在GoogleNet中最后一层卷积层后采用平均池化的方法，大大降低了第一层全连接层的参数；</p>
<h4 id="串联结构（如VGG）存在的问题"><a href="#串联结构（如VGG）存在的问题" class="headerlink" title="串联结构（如VGG）存在的问题"></a>串联结构（如VGG）存在的问题</h4><p>后面的卷积层只能处理 前层输出的特征图;前层丢失重要信息，后层无法找回。</p>
<p>解决方案：</p>
<p>—每一层尽量多的保留输入信号中的信息。</p>
<h4 id="Inception模块和Inception-V1模块"><a href="#Inception模块和Inception-V1模块" class="headerlink" title="Inception模块和Inception V1模块"></a>Inception模块和Inception V1模块</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211004162758.png" alt></p>
<p>1 * 1 conv：把原来的信息进行压缩整理；</p>
<p>3 <em> 3 conv：提取3 </em> 3的局部特征；</p>
<p>5 <em> 5 conv：提取5 </em> 5的局部特征；</p>
<p>1 * 1 max pooling：提取扩张以后的信息；(max pooling相当于最大化抑制，max pooling对周围信息进行了扩展，比如一片区域内最大值是9，那么经过max pooling后，9的周围就会都变成9，对9这个信号进行加强)</p>
<p>为了保证输出的特征图大小相同，分别对1 <em> 1,3 </em> 3,5 * 5这3个卷积层进行边缘进行0,1,2的零填充；</p>
<h5 id="Inception模块-VS-Inception-V1模块"><a href="#Inception模块-VS-Inception-V1模块" class="headerlink" title="Inception模块 VS Inception V1模块"></a>Inception模块 VS Inception V1模块</h5><p>Inception V1模块增加了3个1 * 1的卷积层，使特征图的深度极大的降低，较少了参数个数和计算量，提高了效率；</p>
<p>1 * 1的卷积核不改变H和W，但是可以降低通道深度；</p>
<h4 id="GoogleNet的总结"><a href="#GoogleNet的总结" class="headerlink" title="GoogleNet的总结"></a>GoogleNet的总结</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>输入为去均值后224 * 224的图像，去均值采用的方法是R、G、B；</p>
<h5 id="平均池化"><a href="#平均池化" class="headerlink" title="平均池化"></a>平均池化</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211004193002.png" alt></p>
<p>与全连接层相连时，采用的池化是平均池化；</p>
<h5 id="辅助分类器损失"><a href="#辅助分类器损失" class="headerlink" title="辅助分类器损失"></a>辅助分类器损失</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211004193250.png" alt></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="平均池化向量化与直接展开向量化有什么区别？"><a href="#平均池化向量化与直接展开向量化有什么区别？" class="headerlink" title="平均池化向量化与直接展开向量化有什么区别？"></a>平均池化向量化与直接展开向量化有什么区别？</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010193207.png" alt></p>
<p>平移不变性：图像中的目标，不管被移动到图片的哪个位置，得到的结果应该是相同的，这就是卷积神经网络的平移不变性。</p>
<h5 id="利用1x1卷积进行压缩会损失信息吗？"><a href="#利用1x1卷积进行压缩会损失信息吗？" class="headerlink" title="利用1x1卷积进行压缩会损失信息吗？"></a>利用1x1卷积进行压缩会损失信息吗？</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010193618.png" alt></p>
<p>因为一个图像经过卷积核后，只有满足卷积核特征的地方值才会很大，其余基本上为0；又因为一个图像上满足某一特征的地方往往又很少，因此得到的特征向量图是十分稀疏的，经过压缩往往是压缩了大量的0，因此非线性压缩通常不会损失信息。</p>
<h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010194206.png" alt></p>
<h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010194303.png" alt></p>
<p>通过前面四种网络的学习，我们几乎可以想到越深层次的网络的学习效果越好；但是其实并不是这样的，当网络较深时，就会出现正反向信息流动不顺畅的问题，ResNet的出现解决了这个问题。</p>
<h4 id="ResNet的贡献"><a href="#ResNet的贡献" class="headerlink" title="ResNet的贡献"></a>ResNet的贡献</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010195045.png" alt> </p>
<h4 id="ResNet残差模块"><a href="#ResNet残差模块" class="headerlink" title="ResNet残差模块"></a>ResNet残差模块</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010195641.png" alt></p>
<ul>
<li>通过公式我们可以看出，即使F(x)不起作用，H(x)还是x的值，从而可以知道F(x)即使不起作用也不会造成负面影响；</li>
<li>原图+细节=锐化；可以理解为F(x)为提取的细节，使x得到了锐化即H(x),当H(x)作为输入时，即可以提取原图中的特征，也可以在上一层提取的细节上进行增强，因此这个前向传播信号也是不容易衰减的；</li>
<li>反向传播时，即使F(x)内梯度为0，x梯度恒为1，也能够使梯度进行回传，保证了反向梯度的通畅；</li>
<li>F(x)=H(x)-X,即残差=输出-输入；输出和输入的差异叫做残差，也因此叫残差模型；</li>
</ul>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010205947.png" alt></p>
<p>第一个Conv 1 * 1的作用：降低通道数，使能够减少参数和计算量；</p>
<p>第二个Conv 1 * 1的作用：增加通道数，使能够和X相加；</p>
<h4 id="ResNet结构"><a href="#ResNet结构" class="headerlink" title="ResNet结构"></a>ResNet结构</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010211858.png" alt></p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><h4 id="为什么残差网络性能那么好？"><a href="#为什么残差网络性能那么好？" class="headerlink" title="为什么残差网络性能那么好？"></a>为什么残差网络性能那么好？</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211010212138.png" alt></p>
<p>普通网络当某一层失去作用时，可能就会瘫痪，而残差网络不用这样；</p>
<p>残差网络会自动适应选择某些层进行工作；</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>介绍了5种经典的卷积神经网络AlexNet、ZFNet、VGG、GoogLeNet和ResNet；</li>
<li>残差网络和Inception V4是公认的推广性能最好的两个分类模型；</li>
<li>特殊应用环境下的模型：面向有限存储资源的SqueezeNet以及面向有限计算资源的 MobileNet和ShuffleNet；</li>
</ul>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/posts/10636/</url>
    <content><![CDATA[<h3 id="全连接神经网络的瓶颈"><a href="#全连接神经网络的瓶颈" class="headerlink" title="全连接神经网络的瓶颈"></a>全连接神经网络的瓶颈</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002204347.png" alt></p>
<p>把图像拉成拉成一维的向量作为输入层；</p>
<p>隐层神经元的参数个数为前一层神经元个数+1；</p>
<p>在全连接神经网络中，当图像较大时，参数就会非常多，因此会出现过拟合和计算困难的情况，而且也不容易学习出有效的东西，此时卷积神经网络就出现了；</p>
<p>全连接神经网络对一些表示成向量形式特别是简洁的向量形式特别有效，比如适合处理小的图像，或则把一些处理过的数据获得的简洁结果作为输入；</p>
<h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><h4 id="卷积神经网络层次结构"><a href="#卷积神经网络层次结构" class="headerlink" title="卷积神经网络层次结构"></a>卷积神经网络层次结构</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002174135.png" alt></p>
<p>卷积神经网络分为卷积层、激活层、池化层和全连接层；</p>
<h4 id="卷积神经网络的工作流程"><a href="#卷积神经网络的工作流程" class="headerlink" title="卷积神经网络的工作流程"></a>卷积神经网络的工作流程</h4><p>图像输入——&gt;卷积核组——&gt;获得结果——&gt;全连接神经网络——&gt;分类</p>
<h4 id="基于卷积核组的图像表示"><a href="#基于卷积核组的图像表示" class="headerlink" title="基于卷积核组的图像表示"></a>基于卷积核组的图像表示</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002174913.png" alt></p>
<p>卷积神经网络的卷积核和纹理的原理基本一致；</p>
<p>如果特征响应图某一点较亮，说明原图像这一点存在该特征；</p>
<h4 id="卷积网络中的卷积核"><a href="#卷积网络中的卷积核" class="headerlink" title="卷积网络中的卷积核"></a>卷积网络中的卷积核</h4><ul>
<li>不仅具有宽和高，还具有深度，常写成如下形式： 宽度 x 高度 x 深度</li>
<li>卷积核参数不仅包括核中存储的权值，还包括一个偏置值</li>
</ul>
<h4 id="设计卷积核"><a href="#设计卷积核" class="headerlink" title="设计卷积核"></a>设计卷积核</h4><p>只需要设计卷积核的W,H和卷积核个数，因为卷积核深度由前一层的卷积核个数决定；</p>
<h4 id="卷积网络中的卷积操作"><a href="#卷积网络中的卷积操作" class="headerlink" title="卷积网络中的卷积操作"></a>卷积网络中的卷积操作</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002175339.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002175419.png" alt></p>
<p>特征响应图中每个位置上的值反映了图像上对应位置是否存在卷积核所记录的基元结构信息；</p>
<p>浅层次的卷积核只是记录边缘，深层次的卷积核记录可能就是一个模板；</p>
<h4 id="卷积步长"><a href="#卷积步长" class="headerlink" title="卷积步长"></a>卷积步长</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002175543.png" alt></p>
<h4 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002175625.png" alt></p>
<h4 id="特征响应图组尺寸计算"><a href="#特征响应图组尺寸计算" class="headerlink" title="特征响应图组尺寸计算"></a>特征响应图组尺寸计算</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002175749.png" alt></p>
<h4 id="池化操作"><a href="#池化操作" class="headerlink" title="池化操作"></a>池化操作</h4><h5 id="池化的作用"><a href="#池化的作用" class="headerlink" title="池化的作用"></a>池化的作用</h5><p>对每一个特征响应图独立进行，降低特征响应图组中每个特 征响应图的宽度和高度，减少后续卷积层的参数的数量，降低计算资源耗 费，进而控制过拟合。 </p>
<ul>
<li>降低计算资源消耗；</li>
<li>扩大感受野，即卷积核变大，方差变大；</li>
</ul>
<h5 id="池化操作-1"><a href="#池化操作-1" class="headerlink" title="池化操作"></a>池化操作</h5><p>对特征响应图某个区域进行池化就是在该区域上指定一个值来 代表整个区域。 </p>
<h5 id="常见的池化操作"><a href="#常见的池化操作" class="headerlink" title="常见的池化操作"></a>常见的池化操作</h5><ul>
<li>最大池化——使用区域内的最大值来代表这个区域； </li>
<li>平均池化——采用区域内所有值的均值作为代表。</li>
</ul>
<p>最大池化可以理解成这几个位置都表现出了某一特征，只是表现强度和位置不一样，把最大强度的选出来；</p>
<h5 id="池化层的超参数"><a href="#池化层的超参数" class="headerlink" title="池化层的超参数"></a>池化层的超参数</h5><p>池化窗口和池化步长</p>
<h5 id="池化示例"><a href="#池化示例" class="headerlink" title="池化示例"></a>池化示例</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002180055.png" alt></p>
<p>池化操作不用填充边；</p>
<h4 id="卷积神经网络如何与全连接神经网络相连"><a href="#卷积神经网络如何与全连接神经网络相连" class="headerlink" title="卷积神经网络如何与全连接神经网络相连"></a>卷积神经网络如何与全连接神经网络相连</h4><ul>
<li>用均值：把每一个特征响应图展成一个向量，即r1,r2….(r表示向量)</li>
<li>用均值：求每个特征响应图的均值，即r1,r2….(r表示均值)</li>
</ul>
<h4 id="损失函数-amp-优化算法"><a href="#损失函数-amp-优化算法" class="headerlink" title="损失函数&amp;优化算法"></a>损失函数&amp;优化算法</h4><ul>
<li>损失函数：交叉熵损失 </li>
<li>优化算法：SGD、带动量的SGD以及ADAM</li>
</ul>
<h3 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h3><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>过拟合的原因是学习样本太少，导致无法训练出能够泛化到新数 据的模型。</p>
<h4 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h4><p>是从现有的训练样本中生成更多的训练数据，其方法是利用多种能 够生成可信图像的随机变换来增加样本。 </p>
<h4 id="数据增强的目标"><a href="#数据增强的目标" class="headerlink" title="数据增强的目标"></a>数据增强的目标</h4><p>模型在训练时不会两次查看完全相同的图像。这让模型能够 观察到数据的更多内容，从而具有更好的泛化能力。</p>
<h3 id="样本增强"><a href="#样本增强" class="headerlink" title="样本增强"></a>样本增强</h3><h4 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002204615.png" alt></p>
<h4 id="随机缩放-amp-抠图"><a href="#随机缩放-amp-抠图" class="headerlink" title="随机缩放&amp;抠图"></a>随机缩放&amp;抠图</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002203209.png" alt></p>
<h4 id="色彩抖动"><a href="#色彩抖动" class="headerlink" title="色彩抖动"></a>色彩抖动</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002203843.png" alt></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211002203904.png" alt></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>卷积神经网络</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积补充知识</title>
    <url>/posts/27188/</url>
    <content><![CDATA[<h3 id="补充材料1：卷积与图像去噪"><a href="#补充材料1：卷积与图像去噪" class="headerlink" title="补充材料1：卷积与图像去噪"></a>补充材料1：卷积与图像去噪</h3><h4 id="图像去噪与卷积"><a href="#图像去噪与卷积" class="headerlink" title="图像去噪与卷积"></a>图像去噪与卷积</h4><h5 id="噪声图像"><a href="#噪声图像" class="headerlink" title="噪声图像"></a>噪声图像</h5><p>噪声的一般表达：这个点的像素比其他点的像素值都大，而且可能还大好多；</p>
<h5 id="图像去噪"><a href="#图像去噪" class="headerlink" title="图像去噪"></a>图像去噪</h5><p>可以使用加权求和的方法达到去噪的目的。</p>
<h5 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h5><p>如果不考虑边界填充，那么卷出来至少少一圈；</p>
<p>填充的层数与模板的大小有关；</p>
<p>一般采取0填充；</p>
<p>除了0填充，还有拉伸填充(将四周边缘像素拉伸)和镜像填充；</p>
<h5 id="卷积平移"><a href="#卷积平移" class="headerlink" title="卷积平移"></a>卷积平移</h5><p>原图</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210928214845.png" alt></p>
<p>向左右平移</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210928214939.png" alt></p>
<h5 id="平均卷积核"><a href="#平均卷积核" class="headerlink" title="平均卷积核"></a>平均卷积核</h5><p>平滑</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210928215043.png" alt></p>
<p>锐化</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210928215137.png" alt></p>
<p>原图-平滑=边缘图；</p>
<p>原图+边缘图=锐化；</p>
<h4 id="高斯卷积核"><a href="#高斯卷积核" class="headerlink" title="高斯卷积核"></a>高斯卷积核</h4><h5 id="平均卷积核存在的问题"><a href="#平均卷积核存在的问题" class="headerlink" title="平均卷积核存在的问题"></a>平均卷积核存在的问题</h5><p>卷积后的图像产生了一些水平和竖直方向的条状(振铃);</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>根据邻域像素与中心的远近程度分配权重，即高斯卷积核；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210928215844.png" alt></p>
<h5 id="高斯卷积核-1"><a href="#高斯卷积核-1" class="headerlink" title="高斯卷积核"></a>高斯卷积核</h5><p>高斯卷积核的性质就是使中心位置权重大边缘位置权重小；</p>
<p>高斯卷积核的作用：去除图像中的高频成分（因为高斯卷积核也是一个平均操作，把高的地方给磨皮，即去除高频成分，另外也可以理解让低频的像素通过，即又称低通滤波器）；</p>
<p>高斯卷积核是一个线性卷积核；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210928220434.png" alt></p>
<p>高斯卷积核各个位置的权值的求法：以中心位置为(0,0),把x，y代入求解，则(0,0)左边为(-1,0)代入求解，以此类推；</p>
<p>对权重值进行归一化处理：不做归一化会出现两个问题(若总和小于1，比如相加之和为0.1，在一个白色图像上，卷完就成25.5，对原图像进行了衰减；若大于1，那么像素值就有可能大于255)</p>
<h5 id="高斯卷积核参数"><a href="#高斯卷积核参数" class="headerlink" title="高斯卷积核参数"></a>高斯卷积核参数</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210929093954.png" alt></p>
<p>根据高斯函数的计算公式，在(0,0)处方差越大，G(0,0)的值越小即权重越小，受周围像素的影响较大，即平滑能力强；同理方差越小，平滑能力越弱；</p>
<p>当相同方差时，G(0,0)处的值，大窗口进行归一化后值小，小窗口值大；</p>
<p>G(0,0)越大，平滑能力越强；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210929100105.png" alt></p>
<p>图像经过1,2两个卷积核卷积后，和图像经过1,2两个卷积核的标准差平方和再开方后的结果是相同的；可以推广到多个；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210929100441.png" alt></p>
<p>一个二维的高斯卷积核可以分解为两个一维的高斯卷积核。</p>
<h4 id="图像噪声与中值滤波器"><a href="#图像噪声与中值滤波器" class="headerlink" title="图像噪声与中值滤波器"></a>图像噪声与中值滤波器</h4><h5 id="图像噪声"><a href="#图像噪声" class="headerlink" title="图像噪声"></a>图像噪声</h5><ul>
<li>椒盐噪声: 黑色像素和白色像 素随机出现；</li>
<li>脉冲噪声: 白色像素随机出现；</li>
<li>高斯噪声: 噪声强度变化服从高斯分布（正态分布）</li>
</ul>
<h5 id="高斯去噪"><a href="#高斯去噪" class="headerlink" title="高斯去噪"></a>高斯去噪</h5><p>高斯卷积核可以去除高斯噪声，并且噪声方差越大，卷积核也应越大；</p>
<p>椒盐噪声和脉冲噪声不能使用高斯卷积核达到去噪的效果；</p>
<h5 id="中值滤波器"><a href="#中值滤波器" class="headerlink" title="中值滤波器"></a>中值滤波器</h5><p>它是一个空的3 <em> 3或5 </em> 5…的模板套在数据集上，然后把所有像素值进行排序，找到中位数，用中位数去替换模板中间位置的数。<br>好处：它的值一定是图像上某一点的值；</p>
<h3 id="补充材料2：卷积和边缘提取"><a href="#补充材料2：卷积和边缘提取" class="headerlink" title="补充材料2：卷积和边缘提取"></a>补充材料2：卷积和边缘提取</h3><h4 id="边缘提取"><a href="#边缘提取" class="headerlink" title="边缘提取"></a>边缘提取</h4><h5 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h5><p>图像中亮度明显而急剧变化的点；</p>
<h5 id="为什么要研究边缘"><a href="#为什么要研究边缘" class="headerlink" title="为什么要研究边缘"></a>为什么要研究边缘</h5><ul>
<li>编码图像中的语义和图像信息</li>
<li>想对于像素表示，边缘表示显得更加紧凑</li>
</ul>
<h5 id="边缘的种类"><a href="#边缘的种类" class="headerlink" title="边缘的种类"></a>边缘的种类</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210930104530.png" alt></p>
<p>表面法向不连续：两个面交界的地方会形成边；</p>
<p>深度不连续：不是真实存在的，比如拍照时照不到形成的边；</p>
<p>表面颜色不连续：物品上的细节，例如字等；</p>
<p>光照不连续：阴影；</p>
<h5 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210930105001.png" alt></p>
<p>图像中亮度明显而急剧变化的地方称为边缘，从而可知边缘处相邻处像素相差较大，即一阶导数的绝对值较大；</p>
<h5 id="图像求导"><a href="#图像求导" class="headerlink" title="图像求导"></a>图像求导</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210930105233.png" alt></p>
<p>可以根据图像求导找出图像的边缘，边缘处的导数最大；</p>
<p>在计算图像求导时，ε=1，则经过化简可得，某一像素点处的导数等于它右边的像素减去它自己的像素；</p>
<p>并且可以通过卷积核实现对x,y的求导；</p>
<h5 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210930105900.png" alt></p>
<p>梯度指向灰度变化最快的方向；</p>
<p>信号方向与梯度方向垂直，所以通过梯度方向还可以知道信号大概的方向；</p>
<p>图像梯度通常由暗的地方指向亮的地方；</p>
<p>梯度的值越大，表明是边缘的可能性就越大；</p>
<h4 id="高斯一阶偏导卷积核"><a href="#高斯一阶偏导卷积核" class="headerlink" title="高斯一阶偏导卷积核"></a>高斯一阶偏导卷积核</h4><h5 id="噪声的影响"><a href="#噪声的影响" class="headerlink" title="噪声的影响"></a>噪声的影响</h5><p>对于含有噪声的图像是不能直接求导求边缘的，需要先平滑，如果直接求导将很难判断边缘；</p>
<p>注：这的噪声一般都是指高斯噪声；</p>
<h5 id="平滑去噪再求导"><a href="#平滑去噪再求导" class="headerlink" title="平滑去噪再求导"></a>平滑去噪再求导</h5><p><img src="/C:/Users\RomanticQq\AppData\Roaming\Typora\typora-user-images\image-20211001103924027.png" alt="image-20211001103924027"></p>
<p>先用高斯卷积核去噪以后再对去噪后的图像进行求导；</p>
<h5 id="高斯一阶偏导"><a href="#高斯一阶偏导" class="headerlink" title="高斯一阶偏导"></a>高斯一阶偏导</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001104331.png" alt></p>
<p>高斯一阶偏导是先对高斯卷积核求偏导，因为卷积操作满足交换律和结合律；</p>
<p>对高斯卷积核求导后的结果称为高斯一阶偏导；</p>
<h5 id="高斯一阶偏导卷积核-1"><a href="#高斯一阶偏导卷积核-1" class="headerlink" title="高斯一阶偏导卷积核"></a>高斯一阶偏导卷积核</h5><p>高斯一阶偏导卷积核只有一个参数，就是方差；</p>
<p>方差越小，获取的图像边缘越清晰；方差越大，获取的图像边缘越粗糙；</p>
<p>方差小关注细颗粒度，方差大关注粗颗粒度；</p>
<h5 id="高斯核-VS-高斯一阶偏导核"><a href="#高斯核-VS-高斯一阶偏导核" class="headerlink" title="高斯核 VS 高斯一阶偏导核"></a>高斯核 VS 高斯一阶偏导核</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001105135.png" alt></p>
<p>高斯一阶偏导卷结合总和是0是可以证明的，它表名了在一个没有像素变化图像的图像上，梯度恒为0；</p>
<h4 id="边缘目标检测"><a href="#边缘目标检测" class="headerlink" title="边缘目标检测"></a>边缘目标检测</h4><h5 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001110823.png" alt></p>
<p>利用高斯偏导卷积核求出的图像可能会出现较粗的边，这是由于某处它附近的梯度值都很大的缘故，此时需要用到非极大值抑制；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001110940.png" alt></p>
<p>p点的梯度强度需要与它正梯度方向和反梯度方向的点去进行比较，如果比这两个梯度都强保留，否则删去；</p>
<h5 id="Canny边缘检测器"><a href="#Canny边缘检测器" class="headerlink" title="Canny边缘检测器"></a>Canny边缘检测器</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001112548.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001112618.png" alt></p>
<p>用一个高门限把高阈值留下来，然后这些低阈值就会产生很多边，把那些跟高阈值有连接的边留下来；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001112938.png" alt></p>
<h3 id="补充材料3：纹理表示"><a href="#补充材料3：纹理表示" class="headerlink" title="补充材料3：纹理表示"></a>补充材料3：纹理表示</h3><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><p>纹理可以区分不同物品，它表示了一些材质或则属性；</p>
<p><img src="/C:/Users\RomanticQq\AppData\Roaming\Typora\typora-user-images\image-20211001163609151.png" alt="image-20211001163609151"></p>
<p>纹理分为规则纹理和随机纹理；</p>
<h4 id="基于卷积核组的纹理表示方法"><a href="#基于卷积核组的纹理表示方法" class="headerlink" title="基于卷积核组的纹理表示方法"></a>基于卷积核组的纹理表示方法</h4><ul>
<li><p>利用卷积核组提取图像中的纹理基；</p>
</li>
<li><p>利用基元的统计信息来 表示图像中的纹理；</p>
</li>
</ul>
<h4 id="卷积核组"><a href="#卷积核组" class="headerlink" title="卷积核组"></a>卷积核组</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001163915.png" alt></p>
<p>卷积核组是有多个卷积核组成的，每个卷积核表示着不同的特征；</p>
<p>比如：第一个卷积核检测水平方向的边，最后一个卷积核检测圆形或斑状物体；</p>
<h4 id="基于卷积核组的图像表示"><a href="#基于卷积核组的图像表示" class="headerlink" title="基于卷积核组的图像表示"></a>基于卷积核组的图像表示</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001164525.png" alt></p>
<p>把每个卷积核得到的特征响应图打平组合成一个向量；</p>
<p>ri的个数等于卷积核组中卷积核的个数；</p>
<h4 id="纹理分类任务"><a href="#纹理分类任务" class="headerlink" title="纹理分类任务"></a>纹理分类任务</h4><ul>
<li><p>忽略基元位置；</p>
</li>
<li><p>关注出现了哪种基元对应的纹理以及基元出现的频率；</p>
</li>
</ul>
<h5 id="基于卷积核组的图像表示-1"><a href="#基于卷积核组的图像表示-1" class="headerlink" title="基于卷积核组的图像表示"></a>基于卷积核组的图像表示</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001164819.png" alt></p>
<p> 该方式采用的每个响应特征的均值，可以减少计算量；</p>
<h5 id="小游戏"><a href="#小游戏" class="headerlink" title="小游戏"></a>小游戏</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20211001165211.png" alt></p>
<p>可见在纹理A中第四个颜色最白表明含有第四个卷积核的特征，即垂直的线条，因为为图像2；</p>
<h5 id="卷积核组设计"><a href="#卷积核组设计" class="headerlink" title="卷积核组设计"></a>卷积核组设计</h5><p>设计重点：</p>
<ul>
<li>卷积核类型（边缘、条形以及点状） </li>
<li>卷积核尺度（3-6个尺度） </li>
<li>卷积核方向（6个角度）</li>
</ul>
<p>卷积核尺度，大尺度提取粗粒度的边，小尺度提取细粒度的边；</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>设计卷积核组；</li>
<li>利用卷积核组对图像进行卷积操作获得对应的特征响应图组; </li>
<li>利用特征响应图的某种统计信息来表示图像中的纹理。</li>
</ul>
<p>图像——&gt;卷积核模板——&gt;特征响应图——&gt;ri特征向量的均值</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>卷积神经网络</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用中遇到的坑</title>
    <url>/posts/48631/</url>
    <content><![CDATA[<ol>
<li><p>目录错乱</p>
<p>几级标题必须按顺序，如果三级标题下直接五级标题就会出问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>全连接神经网络</title>
    <url>/posts/13828/</url>
    <content><![CDATA[<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918161320.png" alt></p>
<h3 id="0-像素表示"><a href="#0-像素表示" class="headerlink" title="0.像素表示"></a>0.像素表示</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918161649.png" alt></p>
<p>如（r1,g1,b1,r2,g2,b2…rn,gn,bn)这样</p>
<h3 id="1-多层感知机"><a href="#1-多层感知机" class="headerlink" title="1.多层感知机"></a>1.多层感知机</h3><h4 id="全连接神经网络"><a href="#全连接神经网络" class="headerlink" title="全连接神经网络"></a>全连接神经网络</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918161939.png" alt></p>
<p>max()叫激活函数。</p>
<p>激活函数不能去掉，去掉就退化成线性分类器。</p>
<h4 id="全连接神经网络的权值"><a href="#全连接神经网络的权值" class="headerlink" title="全连接神经网络的权值"></a>全连接神经网络的权值</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918162041.png" alt></p>
<p>w1可以看做模板，它可以有比类别数更多的分类，就是一个类别可以有多个模板。</p>
<p>比如10中类别的动物，w1可以有50中模板甚至更多，即同一类动物可以有多个模板，把与x得到的结果与w2融合，找到最大的，得出结果。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918162213.png" alt></p>
<p>线性分类器的w行数和类别数相同，而全连接神经网络中只需最外层w的行数和类别数相同。</p>
<h4 id="全连接神经网络与线性不可分"><a href="#全连接神经网络与线性不可分" class="headerlink" title="全连接神经网络与线性不可分"></a>全连接神经网络与线性不可分</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918162318.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918162404.png" alt></p>
<p>线性分类器可用于分离线性可分的，但是线性分类器不能把线性不可分的分开，此时就需要有全连接神经网络这样的模型。</p>
<h4 id="全连接神经网络绘制与命名"><a href="#全连接神经网络绘制与命名" class="headerlink" title="全连接神经网络绘制与命名"></a>全连接神经网络绘制与命名</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918162526.png" alt></p>
<p>每个x相互独立为单独的输入。</p>
<h3 id="2-激活函数"><a href="#2-激活函数" class="headerlink" title="2.激活函数"></a>2.激活函数</h3><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918164220.png" alt></p>
<h4 id="常用的激活函数"><a href="#常用的激活函数" class="headerlink" title="常用的激活函数"></a>常用的激活函数</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918164319.png" alt></p>
<p>sigmoid函数的范围为(0,1);</p>
<p>tanh函数的范围是(-1,1);而且是中心对称的；</p>
<h4 id="网络结构设计"><a href="#网络结构设计" class="headerlink" title="网络结构设计"></a>网络结构设计</h4><ol>
<li><p><strong>用不用隐层，用一个还是用几个隐层？（深度设计）</strong> </p>
</li>
<li><p><strong>每隐层设置多少个神经元比较合适？（宽度设计)</strong></p>
<p>没有确定的答案。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918165009.png" alt></p>
<p>依据分类任务的难易程度来调整神经网络模型的复杂程度。分 类任务越难，我们设计的神经网络结构就应该越深、越宽。但是， 需要注意的是对训练集分类精度最高的全连接神经网络模型，在 真实场景下识别性能未必是最好的（过拟合） 。</p>
</li>
</ol>
<h4 id="全连接神经网络小结"><a href="#全连接神经网络小结" class="headerlink" title="全连接神经网络小结"></a>全连接神经网络小结</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918164808.png" alt></p>
<h3 id="3-softmax与交叉熵"><a href="#3-softmax与交叉熵" class="headerlink" title="3.softmax与交叉熵"></a>3.softmax与交叉熵</h3><h4 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918165313.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918165521.png" alt></p>
<p>softmax函数是把分类的结果得分转换成各种结果的概率。</p>
<h4 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h4><p>在此处交叉熵的意义在于衡量两个分布的不相似度。</p>
<p>计算交叉熵之前要用softmax方法做归一化处理。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918165825.png" alt></p>
<p>相对熵中的p和q是不能交换的，p和q之间不能交距离，只能叫散度，因为二者不满足可交换性。</p>
<p>熵表示的信息量的大小。</p>
<p>比如：中国和巴西踢足球，巴西赢的概率为1，平的概率为0，输的概率为0，这种事情没有信息量，确定性极强，熵为0；</p>
<p>当每种概率都是1/n时，此时熵是最大的，因为结果是不确定的。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918165738.png" alt></p>
<p>通过熵，交叉熵，相对熵的公式可以看出：<strong>交叉熵=熵+相对熵</strong></p>
<p>又因为真实分布的熵为0，此时交叉熵等于相对熵。</p>
<p>因为相对熵又称为KL散度，表示的是两个随机分布之间的差异，且交叉熵等于相对熵，所以可用交叉熵来表示两个随机分布之间的差异。</p>
<h3 id="4-对比多类支撑向量机损失"><a href="#4-对比多类支撑向量机损失" class="headerlink" title="4.对比多类支撑向量机损失"></a>4.对比多类支撑向量机损失</h3><h4 id="交叉熵损失-vs-多类支撑向量机损失"><a href="#交叉熵损失-vs-多类支撑向量机损失" class="headerlink" title="交叉熵损失 vs 多类支撑向量机损失"></a>交叉熵损失 vs 多类支撑向量机损失</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918171843.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918171927.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210918171947.png" alt></p>
<p>很明显，计算出来的交叉熵损失和多类支撑向量机损失的值是不同的。</p>
<p>采用交叉熵损失训练的结果是，某一项分数高时，还要尽可能去压低其余项的分数；</p>
<p>采用多类支撑向量机损失训练的结果是，某一项分数高时，只比其余项高出1即可。</p>
<p>在使用多类支撑向量机损失时，可能会出现loss值几乎没有变但是分类精度却提高了，比如：</p>
<p>【0.35,0.33,0.32】和【0.33,0.35,0.32】，两则计算出的loss值差距很小，但是分类的结果却完全不同。</p>
<h3 id="5-计算图与反向传播"><a href="#5-计算图与反向传播" class="headerlink" title="5.计算图与反向传播"></a>5.计算图与反向传播</h3><h4 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h4><p>计算图是一种有向图，它用来表达输入、输出以及中 间变量之间的计算关系，图中的每个节点对应着一种数学运算。</p>
<p>当多层神经网络时，写出求导后的表达式是不容易的，引入计算图可以实现复杂函数的求导问题。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920150534.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920151419.png" alt></p>
<p>通过计算图计算某处的值，要知道三点：</p>
<ol>
<li>上图中1处的值，即z=x+y处的z值是多少；</li>
<li>上图中2处求导的表达式，即z^2求导的表达式</li>
<li>上图中3处的导数的值；</li>
</ol>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920152101.png" alt></p>
<h4 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920152632.png" alt></p>
<p>总结：</p>
<ol>
<li>通过正向计算出各处的值；</li>
<li>能反向计算是因为有了链式法则；</li>
<li>反向传播最后一个导数为1，因为f对f求导还是1；</li>
<li>所求处的梯度=上游梯度*局部梯度；</li>
<li>上游梯度是指所求处右侧的梯度；局部梯度为所求处右侧圆圈式子里的梯度；</li>
<li>局部梯度的式子若为+1，即为x+1,若为*-1，即为-x,以此类推；</li>
</ol>
<p>存在的问题：因为是相乘操作，当梯度都特别小时，乘着乘着就可能出现梯度消失的情况；</p>
<h4 id="计算图的颗粒度"><a href="#计算图的颗粒度" class="headerlink" title="计算图的颗粒度"></a>计算图的颗粒度</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920153549.png" alt></p>
<p>计算图的颗粒度：每一个门可以是一个很复杂的函数，也可以是简单的加减乘除；函数越复杂代表颗粒度越大；</p>
<p>简单函数的好处是都可以按照基源去操作，坏处是要严格按照链路一步一步去计算；</p>
<p>复杂的函数颗粒度较大，但计算效率较高；</p>
<h4 id="计算图中常见的门单元"><a href="#计算图中常见的门单元" class="headerlink" title="计算图中常见的门单元"></a>计算图中常见的门单元</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920154715.png" alt></p>
<ul>
<li>加法门：左边每个分支的值都等于右边的值；</li>
<li>乘法门：两数互换，再相乘；</li>
<li>拷贝门：左边等于右边的和；</li>
<li>max门：把右边的值赋给左边最大的，其余为0；</li>
</ul>
<h3 id="6-再看激活函数"><a href="#6-再看激活函数" class="headerlink" title="6.再看激活函数"></a>6.再看激活函数</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920211644.png" alt></p>
<h4 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920211751.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920211830.png" alt></p>
<p>通过观察sigmoid函数和tanh函数的图像可知，当x超出一定值后梯度为0，由于链式法则是相乘的就会出现梯度消失的情况。</p>
<p>为了解决这一问题就出现了Leakly ReLU函数</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920212056.png" alt></p>
<p>Leakly ReLU函数在x&gt;0的情况下梯度恒为1，在x&lt;0的情况下恒为0.01；效果较好；</p>
<h4 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920212429.png" alt></p>
<p>梯度爆炸会导致错过良好的w值；</p>
<p>通过限制步长的方法来解决梯度爆炸；</p>
<h4 id="激活函数选择总结"><a href="#激活函数选择总结" class="headerlink" title="激活函数选择总结"></a>激活函数选择总结</h4><p>尽量选择ReLU函数或者Leakly ReLU函数，相对于Sigmoid/tanh， ReLU函数或者Leakly ReLU函数会让梯度流更加顺畅，训练过程收敛 得更快。</p>
<p>由于Sigmoid/tanh函数的特性，一般情况下不会在隐层中使用，但可能会用在输出层，把结果控制在某一个范围中。</p>
<h3 id="7-动量法与自适应梯度-梯度算法的改进"><a href="#7-动量法与自适应梯度-梯度算法的改进" class="headerlink" title="7.动量法与自适应梯度(梯度算法的改进)"></a>7.动量法与自适应梯度(梯度算法的改进)</h3><h4 id="梯度下降算法存在的问题"><a href="#梯度下降算法存在的问题" class="headerlink" title="梯度下降算法存在的问题"></a>梯度下降算法存在的问题</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920213241.png" alt></p>
<p>当存在多个w时，传统梯度下降算法会在陡峭处w会来回震荡，而平坦处的w优化缓慢；</p>
<p>仅仅增大步长并不能加快算法收敛的速度，因为w=w-步长*某点处梯度，增加步长会使陡峭的地方震荡幅度增大(因为陡峭处的梯度值的绝对值较大)，平坦的地方进展仍然缓慢(因为平坦处的梯度值的绝对值较小)；</p>
<h4 id="动量法"><a href="#动量法" class="headerlink" title="动量法"></a>动量法</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920214530.png" alt></p>
<p>动量是有方向的，梯度也是有方向的；</p>
<p>在陡峭的地方，梯度方向是不断变化的，当把一定的梯度累加在一起可能是在某一个方向上一个很小的数；在平坦的地方，梯度的方向是一定的，虽然它是一个很小的数，但是累加起来就是一个较大的数，从而实现梯度较快更新的目的；</p>
<p>动量法累加梯度信息是图中3处，并不是2处，2处是小批量随机梯度下降算法的累加；</p>
<p>动量系数u控制历史信息是不是要被衰减；</p>
<p>若u=0时就退化成梯度下降算法；若u=1时就会不断的加大历史的影响，即v=v+g,即使梯度下降算法走到平坦的区域(g=0)时，v仍然不等于0，那么权值会仍然更新下去，但若v=0.9时，v=0.9v，一定次数后v的值将会非常小。</p>
<p>u的值一般使用0.9；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920215559.png" alt></p>
<p>因为鞍点和局部最小值点的导数都为0，又因为w=w-步长*导数，则w更新不动了，此时通常就认为收敛了，但这是不对的；</p>
<p>加入动量以后，即使局部梯度为0，即g=0,但是v=uv+g不为0，并不会马上停止更新，此时就有可能冲出局部最小点或鞍点 ，找到更优的解。</p>
<h4 id="自适应梯度与RMSProp"><a href="#自适应梯度与RMSProp" class="headerlink" title="自适应梯度与RMSProp"></a>自适应梯度与RMSProp</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920220019.png" alt></p>
<p>自适应梯度算法就是在陡峭的地方用小步长，在平坦的地方用大步长。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920221036.png" alt></p>
<p> 通过计算梯度平方和找出震荡方向和平坦方向，在4中表达式可以看出较大的r学习率较小，较小的r学习率较大，从而达到减少震荡更快达到谷底的目的。</p>
<p>存在问题：因为r一直在累加，当加到很大时，学习率就会趋近于0，失去调节作用；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210920220101.png" alt></p>
<p>RMSProp解决了AdaGrad存在的问题，因为r前面存在ρ,当r加到一定的次数，前面的r就会衰减变得非常小，进而保证r的值永远不会很大。</p>
<p>ρ=0时，仅仅考虑当前梯度的强度；</p>
<p>ρ=1时，r=r，又r初始为0，显示不可能；</p>
<p>ρ一般取0.999；</p>
<p>保留的次数越多，p的值就应该越大，例如：保留一百个数p的值应为0.99(1-1/100=0.99),可以此类推(只是大概而已)；</p>
<h4 id="ADAM"><a href="#ADAM" class="headerlink" title="ADAM"></a>ADAM</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921163331.png" alt></p>
<p>ADAM是动量法和自适应梯度下降算法的结合；</p>
<p>图中3处体现了动量法，图中4处体现了自适应梯度下降算法，图中5处解决了程序初期的冷启动问题；</p>
<p>图中5处解决程序刚开始运行时的冷启动问题：当第一次执行程序，u=0.9，v=0,t=1时:图中3处v=0.1g，若此时去更新梯度则实际步长是非常小的，更新较慢，在图中5处进行修正偏差，u=0.9,t=1此时修正后的v=g,从而解决了程序刚开始执行时梯度更新较慢的问题，随着t的增大，u的t次方趋近于0，从而修正偏差逐渐失去作用，不会对开始一段时间后的更新产生影响；r的更新同理。</p>
<p>t代表程序第t次执行；</p>
<p>一般情况下，u=0.9,ρ=0.999，这两个是经验值，可以直接用。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>动量法：采用累加梯度的思想，降低陡峭处w的变化幅度，增强平坦处w的变化幅度；</p>
<p>自适用梯度和RMSProp：自适应梯度算法的思想是减小陡峭处的步长，增大平坦处的步长，从而提高优化效率，但是存在问题(因为r一直在累加增大，当r太大时，就会对步长失去调节作用)，为解决这个问题就出现了RMSProp算法，它通过给r设置衰减系数的方法，从而防止r的值不会变的很大。</p>
<p>ADAM：ADAM算法是动量法和自适用梯度算法的结合，又加入了修正偏差，解决了冷启动问题(程序刚开始执行时，梯度更新较慢)。</p>
<p>在一般情况下使用ADAM算法，但是它没有动量法+小批量梯度下降算法手动调优的效果好。ADAM算法在大部分任务下可以速度很快。</p>
<p>在实际使用过程中，有可能先用ADAM算法初始学习一下，学不动了用动量法+SGD手动调；也有可能先用动量法+SGD先学习一下，然后用ADAM做后面的加速。</p>
<h3 id="8-权值初始化"><a href="#8-权值初始化" class="headerlink" title="8.权值初始化"></a>8.权值初始化</h3><h4 id="全零初始化"><a href="#全零初始化" class="headerlink" title="全零初始化"></a>全零初始化</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202104.png" alt></p>
<p>全零初始化会使不同的神经元有相同的输出，不能进行正向传播和反向传播；</p>
<h4 id="随机权值初始化"><a href="#随机权值初始化" class="headerlink" title="随机权值初始化"></a>随机权值初始化</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202149.png" alt></p>
<p>如采用较小的随机正态分布采样，通过双曲正切激活函数的图像可知，激活后几乎所有值趋近于0，在经过激活函数所有值就为0，在后面的隐层不能进行正向传播；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202213.png" alt></p>
<p>如采用较大的随机正态分布采样，通过双曲正切激活函数的图像可知，激活后几乎所有值趋近于1和-1，此时局部神经元梯度为0，不能进行反向传播；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202249.png" alt></p>
<h4 id="Xavier初试化"><a href="#Xavier初试化" class="headerlink" title="Xavier初试化"></a>Xavier初试化</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202313.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202338.png" alt></p>
<p>(此处公式推导的原理还不明白)</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202412.png" alt></p>
<p>N为输入的神经元个数；</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202431.png" alt></p>
<h4 id="HE初始化"><a href="#HE初始化" class="headerlink" title="HE初始化"></a>HE初始化</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202452.png" alt></p>
<h4 id="权值初始化小结"><a href="#权值初始化小结" class="headerlink" title="权值初始化小结"></a>权值初始化小结</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210921202518.png" alt></p>
<h3 id="9-批归一化"><a href="#9-批归一化" class="headerlink" title="9.批归一化"></a>9.批归一化</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925140653.png" alt></p>
<p>批归一化就是把输入先调整成0均值1方差的样子，然后再调整成与输入具有相同的分布。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925141101.png" alt></p>
<p>批归一化在非线性激活之前。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925141157.png" alt></p>
<p>γ和β是参数，是通过训练得到的；</p>
<p>经过减均值，除方差后，数据会集中在均值两侧，此时梯度较好，几乎不会出现为0的情况；</p>
<p>批归一化的作用是使数据集中在激活函数的中间位置，使梯度不会出现为0的情况；</p>
<h3 id="10-欠拟合、过拟合与Dropout"><a href="#10-欠拟合、过拟合与Dropout" class="headerlink" title="10.欠拟合、过拟合与Dropout"></a>10.欠拟合、过拟合与Dropout</h3><h4 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h4><p>过拟合——是指学习时选择的模型所包含的参数过多，以至于出现这一模 型对已知数据预测的很好，但对未知数据预测得很差的现象。这种情况下 模型可能只是记住了训练集数据，而不是学习到了数据特征。 </p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925142720.png" alt></p>
<p>一般当出现在验证集上误差增大时即为训练最优状态。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925142825.png" alt></p>
<h5 id="调节模型大小"><a href="#调节模型大小" class="headerlink" title="调节模型大小"></a>调节模型大小</h5><p>调节模型的宽度和深度；</p>
<h5 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h5><p>L2正则损失对于大数值的权值向量进行严厉惩罚，鼓励更加分散的权重向量， 使模型倾向于使用所有输入特征做决策，此时的模型泛化性能好；</p>
<p>使分界面变得平滑，不那么复杂；</p>
<h5 id="随机失活"><a href="#随机失活" class="headerlink" title="随机失活"></a>随机失活</h5><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925143511.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925143602.png" alt></p>
<p>随机失活鼓励权值分散，因为当某些较大的权值被失活时就可能造成神经网络的瘫痪。</p>
<p>解释三：Dropout可以看作模型的集成，因为随机失活，每个随机失活剩余的模型就不同(则可以看作多个模型的集成)，可能会出现不同的分类结果，可以找到分类结果出现最多的那次(相当于投票)。</p>
<h4 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h4><p>欠拟合——模型描述能力太弱，以至于不能很好地学习到数据中的规律。 产生欠拟合的原因通常是模型过于简单。</p>
<h3 id="11-模型正则与超参数优化"><a href="#11-模型正则与超参数优化" class="headerlink" title="11.模型正则与超参数优化"></a>11.模型正则与超参数优化</h3><h4 id="神经网络中的超参数"><a href="#神经网络中的超参数" class="headerlink" title="神经网络中的超参数"></a>神经网络中的超参数</h4><ul>
<li><p>网络结构——隐层神经元个数，网络层数，非线性单元选择等；</p>
</li>
<li><p>优化相关——学习率、dropout比率、正则项强度等；</p>
</li>
</ul>
<h4 id="学习率设置"><a href="#学习率设置" class="headerlink" title="学习率设置"></a>学习率设置</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925145211.png" alt></p>
<h4 id="参数优化方法"><a href="#参数优化方法" class="headerlink" title="参数优化方法"></a>参数优化方法</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925145300.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925145343.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925145404.png" alt></p>
<h4 id="超参数的标尺空间"><a href="#超参数的标尺空间" class="headerlink" title="超参数的标尺空间"></a>超参数的标尺空间</h4><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210925145439.png" alt></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
        <tag>全连接神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>线性分类器</title>
    <url>/posts/51215/</url>
    <content><![CDATA[<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84.PNG" alt></p>
<h3 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h3><p>将图像转换成向量的方法有很多，最直接的方法是将图像矩阵转换成向量<br>图像类型</p>
<ul>
<li>二进制图像(非黑即白)</li>
<li>灰度图像(一个像素由一个bit表示，取值范围0~255；图像的像素取值范围都是0~255，最黑是0，最白是255)</li>
<li>彩色图像(每个像素点有3个值，即有3个bit，分别记录R、G、B)</li>
</ul>
<h3 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h3><ul>
<li>线性分类器是一种线性映射，将输入的图像特征映射为类别分数</li>
<li>有n类图像就有n个w,b,即每类图像都有自己的w,b</li>
<li>把图片放入得到n个分数，分数最大的即为结果<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/%E5%88%86%E7%B1%BB%E5%99%A8%E7%A4%BA%E4%BE%8B.PNG" alt="11111"><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA.PNG" alt></li>
</ul>
<h3 id="为什么从线性分类器开始"><a href="#为什么从线性分类器开始" class="headerlink" title="为什么从线性分类器开始"></a>为什么从线性分类器开始</h3><ul>
<li>形状简单，易于理解</li>
<li>通过层级结构（神经网络）或则高维映射（支持向量机）可以形成功能强大的非线性模型</li>
</ul>
<h3 id="线性分类器的权值"><a href="#线性分类器的权值" class="headerlink" title="线性分类器的权值"></a>线性分类器的权值</h3><p>把w放入一个32 <em> 32 </em> 3的矩阵中，把其中的值规划到0~255之间，生成的图片和目标图片很相似；w记录了该类别信息的平均值，当物体和w越像的时候，他们之间的点乘值就是一个很大的值。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210915092707.PNG" alt></p>
<h3 id="线性分类器的分界面"><a href="#线性分类器的分界面" class="headerlink" title="线性分类器的分界面"></a>线性分类器的分界面</h3><ul>
<li>分数等于0的面试决策面</li>
<li>在分界面的正方向，离分界面越远正确率越高(或把x代入wx+b中，得分越高正确率越高)</li>
</ul>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210915095046.PNG" alt></p>
<p><em>当判断分类器的分类效果时，需要损失函数来帮忙</em></p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数搭建了模型性能与模型参数之间的桥梁，指导模型参数优化。</p>
<ul>
<li>损失函数是一个函数，用于度量给定分类器的预测值与真实值的不一致程度，其输出通常是一个非负实数</li>
<li>其输出的非负实数值可以作为反馈信号来对分类器参数进行调整，以降低当前示例对应的损失值，提升分类器的分类效果</li>
<li>损失为平均损失<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210915100351.PNG" alt></li>
</ul>
<h3 id="多类支持向量机损失"><a href="#多类支持向量机损失" class="headerlink" title="多类支持向量机损失"></a>多类支持向量机损失</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210915100637.PNG" alt><br>用n个w,b对同一样本进行预测得到n个数，把wi,bi预测出的syi除外，拿syi与其他预测值比较，若syi比其他测试值大1，则损失函数为0，否则通过上图公式进行计算；<br>1为限定的边界值，一般取1；<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210915100815.PNG" alt><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210915100825.PNG" alt></p>
<h3 id="问题抢答"><a href="#问题抢答" class="headerlink" title="问题抢答"></a>问题抢答</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210915160643.PNG" alt></p>
<ol>
<li>最小是0；最大可能是正无穷；</li>
<li>损失L可能是n-1，即分类数-1；因为当w,b非常接近于0时，Li的值为n-1,有n个n-1，则L近似为n-1;</li>
<li>Li的值会+1，对训练结果没有影响；</li>
<li>可以代替，因为求和是平均n的倍数，损失大的还是大，损失小的还是小；</li>
<li>使用平方会可能会对训练结果产生影响；</li>
</ol>
<h3 id="正则项和超参数"><a href="#正则项和超参数" class="headerlink" title="正则项和超参数"></a>正则项和超参数</h3><p>问题：假设存在一个w使损失函数为0，这个w是唯一的吗？<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916144101.png" alt><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916144157.png" alt><br>这个时候就引入了正则项。<br>正则项<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916163744.png" alt><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916144626.png" alt><br>正则项的三个作用</p>
<ul>
<li>让解唯一</li>
<li>让模型有了偏好</li>
<li>抵抗过拟合(防止只在训练集在学习的太好)<br>常用的正则项损失函数<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916144725.png" alt><br>Elastic net(L1+L2)是弹性网络正则，即L1和L2组合起来的。<br>超参数<br>是在训练之前自己设置的，而不是在训练过程中学习优化得到的。<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916163712.png" alt></li>
</ul>
<h3 id="什么是参数优"><a href="#什么是参数优" class="headerlink" title="什么是参数优"></a>什么是参数优</h3><p>参数优化<br>参数优化是利用损失函数的输出值作为反馈信号来调整分类器参数，以提升分类器对训练样本的预测能力。<br>优化目标<br>损失函数L是一个与参数w有关的函数，优化的目标就是找到损失函数L达到最优的那组w。</p>
<h3 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h3><p>梯度下降算法<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916150158.png" alt><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916150433.png" alt><br>梯度下降算法的下降过程如L,w坐标图所示，我们可以理解任意一个w都对应一个L,我们从模型上的任意一点开始，若它在单调递减区间，那么它在这一点的梯度方向是向左上的，且导数为负数，因为我们要向负梯度方向移动，即向右下方向，此时随着w的增加L值减小；同理当L在单调增区间时，梯度的值为正，则L随着w的不断减少而减少。</p>
<p>更新权值的计算公式：新权值 = 老权值 - 学习率(步长) * 权值的梯度；</p>
<p>梯度计算方法的比较</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916163626.png" alt></p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916150635.png" alt></p>
<p>数值梯度:近似，慢，易写</p>
<p>解析梯度：精确，快，易错</p>
<p>数值梯度的作用：求梯度时一般是用的是解析梯度，而数值梯度主要用于解析梯度正确性的校验(梯度检查)；若两者的计算结果非常接近，则说明在这部分代码从应该没有问题。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916163548.png" alt></p>
<p>采用梯度下降法，是把所有的样本计算一次才更新一次w,计算量较大，且效率较低。</p>
<p>随机梯度下降法</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916153139.png" alt></p>
<p>方法1：有一百万个样本，算完了一百万个样本更新一次w，更新一百万次w;</p>
<p>方法2：有一百万个样本，每个样本更新一次，更新一百万次w;</p>
<p>那么方法2肯定比方法1好，起码速度上比较快，精确上也接近；</p>
<p>因此，在样本N很大时，权值的梯度计算量很大，下降很慢，改进方法就是采用随机梯度下降法，因为每次只采用有一个样本，梯度更新会更快。</p>
<p>但是就会出现问题：如果有些样本是噪声，那梯度方向会不会沿着反方向走？</p>
<p>随机梯度下降法是每次随机挑选一个样本去更新w,虽然单个样本可能使L向增大的方向走，但大部分样本会让我们整体是一个往下走的方式。</p>
<p>小批量梯度下降算法</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916154442.png" alt></p>
<p>epoch：1个epoch表示用过了一个训练集中的所有样本(并不是所有样本都用过了，而是所用的样本总数达到了N)；</p>
<p>100次迭代每次用100个样本和1000次迭代每次用10个样本，这两则对样本的利用率是一样的；</p>
<p>梯度下降算法总结</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916155907.png" alt></p>
<h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916160021.png" alt></p>
<p>训练集用于对参数的训练，当模型中有超参数时，通过验证集把超参数给选择出来，并通过测试集去测试模型的泛化能力；当对参数和超参数确定的过程中，测试集对模型是不可见的。</p>
<p><em>当数据太少，那么验证集所包含的样本就很少，从而无法统计上代表的数据</em></p>
<h3 id="K折验证和重复的K折验证"><a href="#K折验证和重复的K折验证" class="headerlink" title="K折验证和重复的K折验证"></a>K折验证和重复的K折验证</h3><p>举例：在区分男女的模型中，拿10%的数据作为验证集，且这部分数据都是女生；模型1对男女的区别的正确率都是90%，模型2对男生的正确区分率是0%，对女生的正确区分率是100%；那么结果就会表现出模型2是优秀的，但实际上并不是。</p>
<p>K折验证</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916163357.png" alt></p>
<p>重复的K折验证</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916161342.png" alt></p>
<p>K就是分的块数，常用5折和10折；当大量数据时，一般取5%作为验证集，则不再做交叉验证。</p>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916164132.png" alt></p>
<p>去均值后的数据：去均值就是把数据归到中心来，训练数据时看的是相对差值而不是绝对差值，保证数据不会受到数据范围的影响。</p>
<p>归一化后的数据：保证数据不会受到量纲的影响。</p>
<p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210916164208.png" alt></p>
<p>去相关：让数据独立出来；能尽量减少某些在维度上没有变化的数据，这些数据就不考虑了；</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像分类</tag>
        <tag>线性分类器</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分类任务介绍</title>
    <url>/posts/23252/</url>
    <content><![CDATA[<h3 id="什么是图像分类任务，它有哪些应用场合"><a href="#什么是图像分类任务，它有哪些应用场合" class="headerlink" title="什么是图像分类任务，它有哪些应用场合"></a>什么是图像分类任务，它有哪些应用场合</h3><p>图像分类任务：图像分类任务是计算机视觉中的核心任务，其目的是根据图像信息中所反映的不同特征，把不同类别的图像区分开来。<br>应用场合</p>
<ul>
<li>图像分类：从已知的类别标签中为给定的输入图片选定一个类别标签。</li>
<li>图像识别：知道该物体是什么；</li>
<li>图像搜索：在互联网上搜到该图片的信息(在街上拍个照片去搜索，就知道这个图片在什么位置)</li>
<li>目标检测</li>
<li>图像分割</li>
<li>图像生成</li>
</ul>
<h3 id="图像分类任务有哪些难点"><a href="#图像分类任务有哪些难点" class="headerlink" title="图像分类任务有哪些难点"></a>图像分类任务有哪些难点</h3><p>跨越语义鸿沟，建立像素到语义的映射</p>
<ul>
<li>视角(不同角度看到同一物体是不一样的)</li>
<li>光照(不同的光照照射到同一物体上反应出来是不一样的)</li>
<li>尺寸(从不同的距离看物体大小是不一样的)</li>
<li>遮挡</li>
<li>形变(比如同一只猫趴着和站着是不一样的)</li>
<li>背景杂波(在背景和物体有相似性，背景对识别进行了干扰)</li>
<li>类内形变(同一类物体具有不同的形状，比如各种各样的凳子)</li>
<li>运动模糊(一个像素记录了多个像素的值)</li>
<li>类别繁多</li>
</ul>
<h3 id="基于规则的编码方式是否可行"><a href="#基于规则的编码方式是否可行" class="headerlink" title="基于规则的编码方式是否可行"></a>基于规则的编码方式是否可行</h3><p>硬编码：把人的理解写成代码，通过硬编码的方法识别物体是一件很困难的事情；</p>
<h3 id="什么是数据驱动的图像分类范式"><a href="#什么是数据驱动的图像分类范式" class="headerlink" title="什么是数据驱动的图像分类范式"></a>什么是数据驱动的图像分类范式</h3><ul>
<li>数据集构建(很多猫、狗等的图片和类别标签)</li>
<li>分类器设计和学习(从数据中学习)</li>
<li>分类器决策</li>
</ul>
<h3 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h3><ul>
<li>像素表示(RGB)</li>
<li>全局特征表示(如：GIST，从图像中抽出频率特征，适用于大场景)</li>
<li>局部特征表示(适应于遮挡，用几个区块特征，即使某个区块被遮挡，也可以用别的区块下结论)</li>
</ul>
<h3 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h3><ul>
<li>近邻分类器</li>
<li>贝叶斯分类器</li>
<li><strong>线性分类器</strong></li>
<li>支持向量机分类器</li>
<li><strong>神经网络分类器</strong></li>
<li>随机森林</li>
<li>Adaboost</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul>
<li>0-1损失</li>
<li>多类支持向量机损失</li>
<li>交叉熵损失</li>
<li>L1损失</li>
<li>L2损失</li>
</ul>
<h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>一阶和二阶方法都是迭代优化法。</p>
<ul>
<li>一阶优化方法<ul>
<li><strong>随机下降法</strong></li>
<li><strong>随机梯度下降</strong></li>
<li><strong>小批量随机梯度下降</strong></li>
</ul>
</li>
<li>二阶方法<ul>
<li><strong>牛顿法</strong></li>
<li>BFGS</li>
<li>L-BFGS</li>
</ul>
</li>
</ul>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><ul>
<li>数据集划分(训练集、测试集和验证集)</li>
<li>数据预处理</li>
<li>数据增强(旋转、裁剪)</li>
<li>过拟合和欠拟合(过拟合：在数据集上表现很好，在实际中效果很差；欠拟合：怎么训练都不行，模型太简单而事情太复杂，怎么训练都搞不定)<ul>
<li>减少算法复杂度<ul>
<li>使用权重正则项</li>
<li>使用droput正则化</li>
</ul>
</li>
</ul>
</li>
<li>超参数调整(超参数：确定的参数，比如神经元层数，个数；参数：训练过程中确定的数)</li>
<li>模型集成(通过运用多个模型，使系统性能更好)</li>
</ul>
<h3 id="常用的分类任务评价指标是什么"><a href="#常用的分类任务评价指标是什么" class="headerlink" title="常用的分类任务评价指标是什么"></a>常用的分类任务评价指标是什么</h3><p>正确率 = 分对的样本数/全部样本数<br>错误率 = 1 - 正确率<br>Top1指标与Top5指标</p>
<ul>
<li>top1：分类结果中第一个正确的才是正确的；</li>
<li>top5:分类结果中前五个有一个正确的才是正确的；</li>
</ul>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>图像分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy笔记</title>
    <url>/posts/31802/</url>
    <content><![CDATA[<ol>
<li><p>两个数组相加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ya = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">c = a + b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成np数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = np.array(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成10*10 元素全为0的矩阵</span></span><br><span class="line">array_one = np.zeros([<span class="number">10</span>,<span class="number">10</span>])</span><br><span class="line">print(array_one)</span><br><span class="line"><span class="comment"># 生成10*10 元素全为1的矩阵</span></span><br><span class="line">array_one = np.ones([<span class="number">10</span>,<span class="number">10</span>]) </span><br><span class="line">print(array_one)</span><br><span class="line"><span class="comment"># 只能生成0，1其余数字error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个0～10，每次递增2的数组，不包括10</span></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机数组的创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该函数可以保证生成的随机数具有可预测性，seed里的值相同，生成的随机数相同</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 均匀分布</span></span><br><span class="line"><span class="comment"># 生成一个范围的整数</span></span><br><span class="line">a = np.random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 生成一个10*10且范围在0～1内的数</span></span><br><span class="line">b = np.random.rand(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 生成一个范围内的数</span></span><br><span class="line">c = np.random.uniform(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 正态分布</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>createjs小游戏笔记</title>
    <url>/posts/6052/</url>
    <content><![CDATA[<ol>
<li>创建舞台<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stage = <span class="keyword">new</span> createjs.Stage();<span class="comment">//()中为画布的id,与画布进行绑定</span></span><br></pre></td></tr></table></figure></li>
<li>创建容器<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gameView = <span class="keyword">new</span> createjs.Container();</span><br><span class="line">stage.addChild(gameView);<span class="comment">//可将容器放在舞台中，创建的元素放在容器中</span></span><br><span class="line">stage &gt; container &gt; 单个元素<span class="comment">//三代之间的关系，可通过addChild()方法进行追加元素</span></span><br></pre></td></tr></table></figure></li>
<li>创建图形<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> createjs.Shape();<span class="comment">//创建一个图形</span></span><br><span class="line">shape.graphics.beginFill(color)drawRect(x,y,w,h);<span class="comment">//画一个矩形</span></span><br><span class="line">shape.graphics.beginFill(color)drawRoundRect(x,y,w,h,radius);<span class="comment">//画圆角矩形</span></span><br><span class="line">shape.graphics.beginFill(color)drawCircle(x,y,r);<span class="comment">//画圆</span></span><br></pre></td></tr></table></figure></li>
<li>创建图片<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> createjs.Bitmap();<span class="comment">//括号中为图片路径</span></span><br></pre></td></tr></table></figure></li>
<li>创建文字<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="keyword">new</span> createjs.Text(text,font,color);<span class="comment">//创建文字</span></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">text.lineWidth  <span class="comment">//设置行宽</span></span><br><span class="line">text.lineHeight <span class="comment">//设置行高</span></span><br><span class="line">text.textAlign  <span class="comment">//设置对齐方式</span></span><br><span class="line">注：</span><br><span class="line">当设置左对齐的时候，text.x的值为文字的起始点横坐标；</span><br><span class="line">当设置右对齐的时候，text.x的值为文字的结束点横坐标；</span><br><span class="line">当设置居中对齐的时候，text.x的值为文字的中间点横坐标；</span><br><span class="line">当设置lineWidth会出现中文不换行问题见<span class="number">19</span>；</span><br></pre></td></tr></table></figure></li>
<li>常见属性和方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">demo.x <span class="comment">//设置起始位置横坐标</span></span><br><span class="line">demo.y <span class="comment">//设置起始位置纵坐标</span></span><br><span class="line">demo.alpha <span class="comment">//设置透明度</span></span><br><span class="line">demo.x <span class="comment">//设置起始位置横坐标</span></span><br><span class="line">demo.y <span class="comment">//设置起始位置纵坐标</span></span><br><span class="line">demo.scaleX <span class="comment">//水平变换</span></span><br><span class="line">demo.scaleY <span class="comment">//垂直变换</span></span><br><span class="line">demo.scale  <span class="comment">//整体变换</span></span><br><span class="line">demo.alpha  <span class="comment">//设置透明度</span></span><br><span class="line">demo.mask   <span class="comment">//设置蒙版</span></span><br><span class="line">demo.name   <span class="comment">//设置名称</span></span><br><span class="line">demo.visible <span class="comment">//设置元素是否显示 </span></span><br><span class="line">demo.removeAllChildren(); <span class="comment">//移除所有子元素</span></span><br><span class="line">parent.addChild(child); <span class="comment">//添加子元素</span></span><br><span class="line">parent.setChildIndex(child,parent.getNumChildren()-num);<span class="comment">//设置层级</span></span><br><span class="line">注：</span><br><span class="line"><span class="number">1.</span> 当alpha为<span class="number">0</span>时不能触发事件；</span><br><span class="line"><span class="number">2.</span> mask显示的内容为和蒙版重合的部分，为蒙版不追加入img的父元素中；</span><br></pre></td></tr></table></figure></li>
<li>雪碧图<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    images: [url],<span class="comment">//图片路径</span></span><br><span class="line">    frames: &#123;<span class="attr">width</span>:w,<span class="attr">height</span>:h,<span class="attr">count</span>:count&#125;,<span class="comment">//w,h是一张精灵图的实际宽高，count的图片数量</span></span><br><span class="line">    animations: &#123;</span><br><span class="line">        run: &#123;</span><br><span class="line">            frames:[<span class="number">0</span>,<span class="number">3</span>],<span class="comment">//显示哪几张图片，0，3为0～3四张</span></span><br><span class="line">            speed:<span class="number">0.5</span> <span class="comment">//图片运动速度</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> spriteSheet = <span class="keyword">new</span> createjs.SpriteSheet(data);</span><br><span class="line"><span class="keyword">let</span> animation = <span class="keyword">new</span> createjs.Sprite(spriteSheet,<span class="string">&quot;run&quot;</span>);</span><br><span class="line">nimation.set(&#123;<span class="attr">x</span>:x,<span class="attr">y</span>:y,<span class="attr">scaleX</span>:scaleX,<span class="attr">scaleY</span>:scaleY&#125;);</span><br></pre></td></tr></table></figure></li>
<li>创建动画<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createjs.Tween.get(元素).to(&#123;属性:值&#125;,时间)；<span class="comment">//异步执行</span></span><br><span class="line">createjs.Tween.get(元素).to(&#123;属性:值&#125;,时间).call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)；<span class="comment">//function()和动画同步执行，会在动画结束后执行</span></span><br></pre></td></tr></table></figure></li>
<li>资源预加载<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.when(filePreload()).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"><span class="comment">//预加载完成后在执行then后面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filePreload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//deferred对象的含义就是&quot;延迟&quot;到未来某个点再执行。</span></span><br><span class="line">    <span class="keyword">let</span> deferred = <span class="keyword">new</span> $.Deferred();</span><br><span class="line">    <span class="comment">//preload可以方便我们预先加载相关资源</span></span><br><span class="line">    <span class="keyword">let</span> queue = <span class="keyword">new</span> createjs.LoadQueue(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//如果载入声音，必须先注册createjs.Sound</span></span><br><span class="line">    queue.installPlugin(createjs.Sound);</span><br><span class="line">    <span class="comment">//将需要预加载的资源放在manifest数组中</span></span><br><span class="line">    <span class="comment">//url：资源的路径</span></span><br><span class="line">    <span class="comment">//id:给资源重新定义的名字，调用改资源时使用</span></span><br><span class="line">    <span class="keyword">let</span> manifest = [</span><br><span class="line">        &#123;<span class="attr">id</span>:id,<span class="attr">src</span>:url<span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">    ];</span></span><br><span class="line"><span class="string">    //预加载过程中执行的函数</span></span><br><span class="line"><span class="string">    //当调用某一资源时使用bitmapList[id].clone(),且bitmapList需为全局变量</span></span><br><span class="line"><span class="string">    queue.on(&quot;</span>fileload<span class="string">&quot;, function (event) &#123;</span></span><br><span class="line"><span class="string">        if (event.item.type == &quot;</span>image<span class="string">&quot;) &#123;</span></span><br><span class="line"><span class="string">            bitmapList[event.item.id] = new createjs.Bitmap(event.result);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;, this);</span></span><br><span class="line"><span class="string">    //预加载完成后执行的函数</span></span><br><span class="line"><span class="string">    queue.on(&quot;</span>complete<span class="string">&quot;, function (event) &#123;</span></span><br><span class="line"><span class="string">        deferred.resolve();</span></span><br><span class="line"><span class="string">    &#125;, this);</span></span><br><span class="line"><span class="string">    queue.loadManifest(manifest);</span></span><br><span class="line"><span class="string">    return deferred.promise();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>设置旋转(竖屏转成横屏) <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stage.rotation = <span class="number">90</span>;</span><br><span class="line">stage.x = screenWidth;</span><br><span class="line">stage.y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> temp = screenWidth;</span><br><span class="line">screenWidth = screenHeight;</span><br><span class="line">screenHeight = temp;</span><br><span class="line">注：等号右侧为竖屏宽高，左侧为横屏宽高</span><br></pre></td></tr></table></figure></li>
<li>当使用高清图片时若图片还是不清晰，可适当扩大画布的倍数；</li>
<li>当使用onload方法且需要传参时，避免异步的影响<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如加载图片时，图片没有加载好就获取图片属性会报错</span></span><br><span class="line"><span class="comment">//若在for循环中，可能计数i会产生影响</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = url;</span><br><span class="line">img.index = <span class="number">1</span>;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img.index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可推广</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.x = <span class="number">1</span>;</span><br><span class="line">obg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>动态修改shape图形的参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shape.graphics.command.属性 = 值；</span><br></pre></td></tr></table></figure></li>
<li>实现container的滚动<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">if</span>(createjs.Touch.isSupported() == <span class="literal">true</span>)&#123;</span><br><span class="line">        createjs.Touch.enable(stage)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//设置滚动条件</span></span><br><span class="line"><span class="keyword">let</span> localPos,y;</span><br><span class="line">gameView.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//滑动开始时的位置</span></span><br><span class="line">    <span class="keyword">let</span> stageX = evt.stageX;</span><br><span class="line">    <span class="keyword">let</span> stageY = evt.stageY;</span><br><span class="line">    <span class="comment">//将gameView对象从舞台（全局）坐标转换为显示对象的（本地）坐标</span></span><br><span class="line">    localPos = stage.globalToLocal(stageX,stageY);</span><br><span class="line">    <span class="comment">//获取gameview对象的坐标</span></span><br><span class="line">    y = gameView.y;</span><br><span class="line">&#125;)</span><br><span class="line">gameView.addEventListener(<span class="string">&#x27;pressmove&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//gameview.y = 滑动结束时滑动点处的y-滑动开始时滑动点处的y+滑动开始时gameview的y</span></span><br><span class="line">    <span class="keyword">let</span> move_y = evt.stageY - localPos.y + y;</span><br><span class="line">    <span class="comment">//通过滑动区域y坐标的大小限制滑动区域</span></span><br><span class="line">    <span class="keyword">if</span>(move_y &gt;= -(滑动区域.y-显示区域.y) &amp;&amp; move_y &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        gameView.y = move_y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>全局只需要在入口函数设置tick刷新舞台即可；</li>
<li>适配不同的手机屏幕可通过长宽比例进行适配； </li>
<li>js合并两个数组<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr1 = arr1.concat(arr2);</span><br></pre></td></tr></table></figure></li>
<li>获取屏幕的宽高<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> screenWidth = <span class="built_in">window</span>.innerWidth;</span><br><span class="line"><span class="keyword">let</span> screenHeight = <span class="built_in">window</span>.innerHeight;</span><br></pre></td></tr></table></figure></li>
<li>EaselJS的Text中文不会自动换行的问题<br>修改easeljs的p._drawText方法为<br><a href="https://pasteme.cn/135634">点击</a></li>
<li><p>解决createjs的点击图片跨域问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在图片上面盖上一个形状，使图片不触发单击时间</span></span><br><span class="line"><span class="keyword">var</span> hitArea = <span class="keyword">new</span> createjs.Shape();</span><br><span class="line">hitArea.graphics.beginFill(<span class="string">&quot;#000&quot;</span>).drawRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">92</span>,<span class="number">92</span>);<span class="comment">//这里是图片大小</span></span><br><span class="line">bitmap.hitArea = hitArea;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>createjs</tag>
      </tags>
  </entry>
  <entry>
    <title>解决createjs适配手机横屏的问题</title>
    <url>/posts/12082/</url>
    <content><![CDATA[<span id="more"></span> 
<p>当用createjs做手机游戏开发，通常会遇到游戏横屏的问题，此时难以开发，下面通过一些代码去解决这一问题。<br><!-- more --><br>当开发时，可以通过谷歌浏览器打开手机横屏调试界面，进行页面的布局，并在布局前通过下面代码或得手机屏幕的宽高，然后进行适配:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;测试</span><br><span class="line">&#x2F;&#x2F; var gameScale &#x3D; screenWidth&#x2F;375;</span><br><span class="line">&#x2F;&#x2F; gameView.rotation &#x3D; 90;</span><br><span class="line">&#x2F;&#x2F; gameView.x &#x3D; screenWidth;</span><br><span class="line">&#x2F;&#x2F; gameView.y &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; screenWidth &#x3D; window.innerHeight;</span><br><span class="line">&#x2F;&#x2F; screenHeight &#x3D; window.innerWidth;</span><br><span class="line">&#x2F;&#x2F;开发</span><br><span class="line">screenWidth &#x3D; window.innerWidth;</span><br><span class="line">screenHeight &#x3D; window.innerHeight;</span><br></pre></td></tr></table></figure></p>
<p>当测试时，可以通过旋转屏幕的方式查看手机横屏后的效果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;测试</span><br><span class="line"> var gameScale &#x3D; screenWidth&#x2F;375;</span><br><span class="line"> gameView.rotation &#x3D; 90;</span><br><span class="line"> gameView.x &#x3D; screenWidth;</span><br><span class="line"> gameView.y &#x3D; 0;</span><br><span class="line"> screenWidth &#x3D; window.innerHeight;</span><br><span class="line"> screenHeight &#x3D; window.innerWidth;</span><br><span class="line">&#x2F;&#x2F;开发</span><br><span class="line">&#x2F;&#x2F;screenWidth &#x3D; window.innerWidth;</span><br><span class="line">&#x2F;&#x2F;screenHeight &#x3D; window.innerHeight;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>createjs</tag>
      </tags>
  </entry>
  <entry>
    <title>解决空html页面有hight的问题</title>
    <url>/posts/20921/</url>
    <content><![CDATA[<p>可能是由于meta的标签的问题，更换成下面meta标签中的内容。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta content=<span class="string">&quot;width=device-width,initial-scale=1,user-scalable=no&quot;</span> name=<span class="string">&quot;viewport&quot;</span>&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel8路由</title>
    <url>/posts/30139/</url>
    <content><![CDATA[<ol>
<li><p>get请求</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Route::get(<span class="string">&#x27;/aaa&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(<span class="string">&#x27;/aaa&#x27;</span>,[TestController::class,<span class="string">&#x27;form&#x27;</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>post请求</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Route::post(<span class="string">&#x27;/aaa&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::post(<span class="string">&#x27;/aaa&#x27;</span>,[TestController::class,<span class="string">&#x27;form&#x27;</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个路由响应多个http请求动作</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Route::match([<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;post&#x27;</span>], <span class="string">&#x27;foo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This is a request from get or post&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个路由来响应所有 HTTP 请求动作</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Route::any(<span class="string">&#x27;bar&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;This is a request from any HTTP verb&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>重定向路由</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Route::redirect(<span class="string">&#x27;/here&#x27;</span>,<span class="string">&#x27;/aaa&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>视图路由<br> ```php<br> Route::view(‘hello’, ‘hello’, [‘name’ =&gt; ‘学院君’]);<br> <h1><pre><code> Hello, &#123;&#123; $name &#125;&#125;!
</code></pre> &lt;/h1&gt;<br> 注：在view中第一个参数为URL，第二个参数为视图名称，第三个参数可选为需要传到视图文件的值</h1></li>
</ol>
<ol>
<li>路由参数<br> ```php<br> //必选参数<br> Route::get(‘user/{id}’, function ($id) {<pre><code> return &#39;User &#39; . $id;
</code></pre> });<br> //可选参数  可以设置默认值<br> Route::get(‘user/{id？}’, function ($id=1) {<pre><code> return &#39;User &#39; . $id;
</code></pre> });<br> //多个参数<br> Route::get(‘posts/{post}/{comment}’, function ($postId, $commentId) {<pre><code> return $postId . &#39;-&#39; . $commentId;
</code></pre> });</li>
</ol>
<ol>
<li><p>正则约束<br>```php<br>//判断一个值<br>Route::get(‘user/{id}’, function ($id) {</p>
<pre><code>// $id 必须是数字
</code></pre><p>})-&gt;where(‘id’, ‘[0-9]+’);<br>//判断多个值<br>Route::get(‘user/{id}’, function ($id) {</p>
<pre><code>// $id 必须是数字
</code></pre><p>})-&gt;where(‘id’, ‘[0-9]+’);</p>
</li>
<li><p>全局约束</p>
<p>```php<br>//需要在 RouteServiceProvider 类的 boot 方法中定义这种约束模式<br>public function boot()<br>{</p>
<pre><code>Route::pattern(&#39;id&#39;, &#39;[0-9]+&#39;);
</code></pre><p>}<br>Route::get(‘user/{id}’, function ($id) {</p>
<pre><code>// 只有当 &#123;id&#125; 是数字时才会被调用
</code></pre><p>});</p>
</li>
</ol>
<ol>
<li>分组前缀<br>```php<br>Route::prefix(‘sss’)-&gt;group(function (){<br>Route::get(‘index’,function (){<br>return 33;<br>});<br>Route::get(‘welcome’,function (){<br>return 44;<br>});<br>});<br>//访问时路由为/sss/index或/sss/welcome</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下搭建LAMP</title>
    <url>/posts/8665/</url>
    <content><![CDATA[<h4 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h4><ol>
<li><p>安装Apache</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install httpd -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service httpd restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache服务开机启动</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig httpd on</span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache的配置文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>网站根目录</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h4><ol>
<li><p>安装mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;repo.mysql.com&#x2F;mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动mysql</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>首次登录mysql</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置密码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">use mysql;</span><br><span class="line">select user,password from user;</span><br><span class="line">update user set password&#x3D;password(&#39;root&#39;) where user&#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mysql刷新权限命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次登录mysql</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root(用户名) -p</span><br><span class="line">root（密码）</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h4><ol>
<li><p>安装php和连接php、mysql工具</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install php php-mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Apache和mysql</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service httpd restart</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试php和mysql是否连接成功</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$link &#x3D; mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;);</span><br><span class="line">if($link)&#123;</span><br><span class="line">echo &quot;successful&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;fail&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol>
<li><p>报错Cannot find a valid baseurl for repo： base/7/86-64</p>
<p> 解决方案：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scriptsls</span><br><span class="line">vim ifcfg-ens33</span><br><span class="line">   ONBOOT&#x3D;yes &#x2F;&#x2F;修改,保存退出即可</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LAMP</tag>
        <tag>服务器</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次来北京</title>
    <url>/posts/8642/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说实话，以前也来过两次北京，与其说来过，不如说是路过。这是算是真正意义的来北京吧，顺利成为北漂的一员。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;北京给我的印象是贵：下面简单算一下每天的日常开销吧。首先早上上班坐地铁5元，早餐一杯豆浆3.5元，中午定外卖大约20元，下班坐地铁5元，晚餐一碗鸡蛋汤和四个煎包6元，房租水电65元，共计105元；一个月下来不买零食、不买生活用品、不买衣服、没有任何事情，需要3150元，但是不可能没有别的事，也不可能什么都不买，因此一个月四千元在北京应该算是基本开销了吧。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;北京给我的印象是人多：感觉在地铁上能坐到座位的概率应该跟中彩票差不多了吧。虽然有点夸张，但事实是我上下班确实没有坐到过位置，即使是始发站。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;北京给我的印象是机会多：我面了将近十家公司，各种各样的都有，只有你想工作，应该都能找到相对合适的，但前提是你要一个一个去面，面完了你才能知道适不适合你。</p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次面试-2021北京暑假实习</title>
    <url>/posts/48614/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;终于稳定下来了，一直想把最近的面试经历记录下来，可是由于一直在忙着找房子和工作，今天终于有时间可以写一写了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一周面试了大概有十家左右，虽然每天跑的感觉特别疲惫，但从失败的教训中确实也学到了好多东西。在面试的过程中，一般都会先要求自我介绍，然后给一些笔试题做一下，再就是技术面试。这几场面试下来，给我的感觉不仅是一些知识自己没有熟练掌握，更重要的是有些技术自己根本就没有听说过、考虑过或使用过。以前在学校的时候感觉在同学中应该还算个中等水平，现在感觉自己就是一个井底之蛙，我觉得这才是最可怕的地方。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这么多面试官中给我留下印象最深刻的是乔，他面了我三次，最然他最后没有录用我，但是我觉得他给了我更重要的东西。一面是电话面试，他简单的问了我一些计算机专业的知识，然后让我给他介绍毕设；二面的时候是在公司，他指出我毕设数据库表的设计有问题，并现场让我改正，写了对数据库的增删改查的一些功能。这里要说了，这是我所有的面试中唯一一个让现场写代码的。一开始我以为是个特例，后来问了同学，他们说他们面的时候也需要现场写。后来由于他有事，他给我布置了两个问题，让我写一下，问题分别是：(1)写一个单例模式，并写出对它的理解；(2)根据对数据库的修改去修改响应的代码；三面的时候，第一个问题写单例模式，虽然最后写出来了，但是写的特别慢，又问我你还看了别的设计模式了吗？我说没有；后来看到我写的文档数据库表中字段名起的规则不一致，说我命名不严谨；最后问我在二面的时候代码中那个bug修改了没有，我说没有；结果可想而知，我肯定是被pass掉了。原因：他说单例模式你虽然写出来了但是写的太慢了，你在关注这个模式的时候没有去考虑别的设计模式；遇到的bug这都好几天了，你应该已经解决了但是你并没有解决了，给我的感觉是你并没有那么喜欢计算机这个行业；还有就是对数据库字段命名的时候没有自己的原则，可见没有良好的代码习惯。纵使我说我很喜欢，但是靠嘴说是没有用的。随后他给我讲了一些计算机大面上的东西，虽然不是具体知识上面的，但我感觉确实受益匪浅。其中有一个问题就是：你喜欢广度优先还是深度优先？还告诉我要有长期的目标，以及产品、需求和代码之间的关系等。虽然当时我没有通过面试，心情非常失落，但是我获得了更重要的东西。我特别特别感谢他，他一下子把我拍醒了，让我对自己有了一个更加清楚的认识。从这次面试失败的经历中，我感觉到有两点特别重要：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 细节决定成败；</span><br><span class="line"><span class="number">2.</span> 对于遇到的问题要及时去解决，问题本身就是最宝贵的；</span><br></pre></td></tr></table></figure><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些话一直在说，但是没有教训的话，可能体会的并没有那么深刻。</p>
<h5 id="遇到的频率比较高的问题"><a href="#遇到的频率比较高的问题" class="headerlink" title="遇到的频率比较高的问题"></a>遇到的频率比较高的问题</h5><ol>
<li>时间复杂度；</li>
<li>队列和栈； </li>
<li>冒泡排序和快排；</li>
<li>五层模型和七层模型；</li>
<li>http和https；</li>
<li>TCP和UDP；</li>
<li>线程和进程；</li>
<li>数据库优化；</li>
<li>事务；</li>
<li>SQL语句的书写；</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/46132/</url>
    <content><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ol>
<li>单例模式的简述：<br>单例模式就是确保某个类只有一个实例，而且这个实例一般都是自行实例化，不需要再去new这个类，通过一个全局访问点去访问，一般常见的如类名。</li>
<li>为什么要使用单例模式：<br>在开发过程中，经常会遇到一些对象，这样的对象在全局当中仅仅存在一个就可以了，如执行SQL语句时连接数据库的操作。如果这种对象出现过多的话，可能会出现各种意外错误。</li>
<li>单例类 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Football</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">static</span>  <span class="variable">$fb</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 构造方法私有化，不能让其他程序去new对象</span></span><br><span class="line"><span class="comment">    * 要想取得该对象，必须由该类提供方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 该方法必须是一个静态方法，只有通过类名才可以调用</span></span><br><span class="line"><span class="comment">    * 先去判断这个对象是否被创建</span></span><br><span class="line"><span class="comment">    * 如果没有则创建；如果存在则返回创建好的对象</span></span><br><span class="line"><span class="comment">    * 以保证该对象只有一个实例</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">static</span>::<span class="variable">$fb</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">static</span>::<span class="variable">$fb</span> = <span class="keyword">new</span> Football();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static</span>::<span class="variable">$fb</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;Football.class.php&#x27;</span>;</span><br><span class="line">header(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//class test &#123;</span></span><br><span class="line"><span class="comment">//    public function test()&#123;</span></span><br><span class="line"><span class="comment">//        $fb1 = Football::getInstance();</span></span><br><span class="line"><span class="comment">//        $fb2 = Football::getInstance();</span></span><br><span class="line"><span class="comment">//        if ($fb1 === $fb2)&#123;</span></span><br><span class="line"><span class="comment">//            echo &quot;fb1和fb2为同一个对象&quot;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="variable">$fb1</span> = Football::getInstance();</span><br><span class="line"><span class="variable">$fb2</span> = Football::getInstance();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 去判断$fb1和$fb2是否为同一个实例</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$fb1</span> === <span class="variable">$fb2</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;fb1和fb2为同一个对象&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax实现文件上传</title>
    <url>/posts/36363/</url>
    <content><![CDATA[<h1 id="1-前端demo"><a href="#1-前端demo" class="headerlink" title="1.前端demo"></a>1.前端demo</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function btnSubmit() &#123;</span><br><span class="line">        var img &#x3D; document.getElementById(&#39;images&#39;).files[0];</span><br><span class="line">        var fd &#x3D; new FormData();</span><br><span class="line">        fd.append(&#39;FILE&#39;, img);</span><br><span class="line">        fd.append(&#39;name&#39;, &#39;xiaoming&#39;);</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;post&quot;,</span><br><span class="line">            url: &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php&quot;,</span><br><span class="line">            processData: false,&#x2F;&#x2F;非常重要，不可省略</span><br><span class="line">            contentType: false,&#x2F;&#x2F;非常重要，不可省略</span><br><span class="line">            dataType: &quot;json&quot;,</span><br><span class="line">            data: fd,</span><br><span class="line">            success: function(data) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            error: function(data) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="2-服务端demo"><a href="#2-服务端demo" class="headerlink" title="2.服务端demo"></a>2.服务端demo</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$imgName&#x3D;$_FILES[&#39;FILE&#39;][&#39;name&#39;];</span><br><span class="line">$tmp_name&#x3D;$_FILES[&#39;FILE&#39;][&#39;tmp_name&#39;];</span><br><span class="line">$fileName&#x3D;&#39;.&#x2F;123.jpg&#39;;</span><br><span class="line">$rst&#x3D;move_uploaded_file($tmp_name,$fileName);</span><br><span class="line">echo $rst;</span><br></pre></td></tr></table></figure>
<p>注：<br>1.$fileName路径中的路径必须存在；<br>2.$fileName路径中不可出现中文；<br>若不满足则两种情况，可能会false；</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记(第二天)</title>
    <url>/posts/46614/</url>
    <content><![CDATA[<ol>
<li><p>String当中与获取有关的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">length:获取字符串长度；</span><br><span class="line">concat:连接两个字符串；</span><br><span class="line">charAt:获取指定索引位置的单个字符；</span><br><span class="line">indexOf:查找参数字符串在本字符串中首次出现的位置；</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串的截取办法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">substring(int index):截取从参数位置一直到字符串末尾，返回新的字符串；</span><br><span class="line">substring(int begin,int end):截取从begin到end的字符串；</span><br><span class="line">备注：[begin,end)</span><br></pre></td></tr></table></figure></li>
<li>string当中与转换相关的常用方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toCharArray():将字符串拆分成为字符数组作为返回值；</span><br><span class="line">getBytes():获得当前字符串底层的字节数组；</span><br><span class="line">replace(oldString,newString):将所有出现的老字符串，替换成新的字符串并返回</span><br><span class="line">split():按照分割参数的规则，将字符串分成若干部分；</span><br></pre></td></tr></table></figure></li>
<li>static关键字<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. static关键字修饰的内容属于类，而不属于对象本身；</span><br><span class="line">2. 用static修饰的变量称为静态变量，修饰的方法称为静态方法；</span><br><span class="line">3. 静态变量和静态方法可以用类名调用，也可以用对象名调用，但推荐用类名调用，因为静态变量和静态方法属于类，而不是对象；</span><br><span class="line">4. 成员方法可以调用静态变量和静态方法；但静态不能调用非静态；</span><br><span class="line">5. 静态代码块：当第一次用到本类时，静态代码块执行唯一的一次；静态内容总是由于非静态，所以静态代码块比构造方法先执行；</span><br><span class="line">6. 在静态方法中不能使用this关键字；</span><br></pre></td></tr></table></figure></li>
<li>Arrays相关常用方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Arrays.toString:将数组变成字符串，并加上[];</span><br><span class="line">2. Arrays.sort:将数组进行排序，数字按升序，字符串按字母升序；</span><br></pre></td></tr></table></figure></li>
<li>extends关键字<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 在继承时，若父子变量名重名，则创建对象时，创建的类对象是谁就用谁，没有就向上找；</span><br><span class="line">2. 在java中只有单继承，没有多继承；</span><br><span class="line">3. 在java中可以多级继承；</span><br><span class="line">4. 无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找父类；</span><br></pre></td></tr></table></figure></li>
<li>重写<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.方法的名称一样，参数列表也一样</span><br><span class="line">2.方法覆盖重写的注意事项：</span><br><span class="line">    1.必须保证父子类之间的方法名称相同，参数列表也相同；</span><br><span class="line">    2.子类的返回值必须小于或等于父类方法的返回值范围；</span><br><span class="line">    3.子类方法的权限必须大于等于父类方法的权限修饰符；</span><br><span class="line">    备注：public&gt;protected&gt;default&gt;private </span><br></pre></td></tr></table></figure></li>
<li>super关键字<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 使用super关键字访问父类的成员变量；</span><br><span class="line">2. 使用super关键字调用父类中的方法(当父类和子类方法名重名时)；</span><br><span class="line">3. 调用父类构造方法；</span><br><span class="line">4. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span><br><span class="line">总结：super关键字的三种用法：</span><br><span class="line">1. 在子类的成员方法中，访问父类的成员变量；</span><br><span class="line">2. 在子类的成员方法中，访问父类的成员方法；</span><br><span class="line">3. 在子类的构造方法中，访问父类的构造方法；</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记(第一天)</title>
    <url>/posts/21767/</url>
    <content><![CDATA[<ol>
<li>Java只有单继承，没有多继承；</li>
<li><p>命名规则：<br>(1)大驼峰：每个单词首字母大写；<br>(2)小驼峰：除了第一个单词首字母小写，其余都大写；</p>
</li>
<li><p>重载：在同一个类中，方法名相同的情况下，可以通过参数不同，参数类型不同进行重载(不能用返回值类型不同进行重载)</p>
</li>
<li>代码千万行，规范第一行；格式不规范，码农两行泪；</li>
<li>数据类型转换：<br>(1)自动类型转换：如int+double会自动转化为double；<br>(2)强制类型转换：如(int)(a+b)；<br>(3)利：可以满足数据类型的一致化；弊：会导致数据类型精度丢失，且不可逆；</li>
<li>数组两种初始化的方法：<br>(1)动态初始化：如int[] a=new int[5];<br>(2)静态初试化：如int[] a=new int[]{1,2,3};<br>注：数组的长度不可变；标准格式初始化可以拆，动态初始化和静态初始化都可以拆；</li>
<li>在java中可以用任何数据类型做参数和返回值；特别之是可以用对象作为参数和返回值；</li>
<li>在写类中对全局变量时，对于Boolean类型的取值是isName，而不是getName；</li>
<li>字符串用双引号；</li>
<li>调用自己类里的方法必须为静态方法；</li>
<li>java的内存需要划分为五个部分：<br>(1)栈：存放的都是方法中的局部变量。方法的运行一定要在栈中；<br>作用域：一旦超出作用域，立刻从栈内存当中消失；<br>(2)堆：凡是new出来的东西，都在堆当中；堆内存里面的东西都有一个地址值：16进制；堆内存里面的数据，都有默认值。规则：<br>如果是整数       默认为0<br>如果是浮点数     默认为0.0<br>如果是字符       默认为’\u0000’<br>如果是布尔       默认为false<br>如果是引用类型   默认为null<br>(3)方法区：存储.class相关信息，包含方法的信息。<br>(4)本地方法栈：与操作系统有关；<br>(5)寄存器：与CPU有关；</li>
<li>构造方法在new时被调用执行；</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>js文件的写法</title>
    <url>/posts/7375/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">owner</span>)</span>&#123;</span><br><span class="line">	owner.btn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(<span class="built_in">window</span>.test=&#123;&#125;)) <span class="comment">//test是js的文件名</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>重邮程序设计复试真题(部分)</title>
    <url>/posts/51387/</url>
    <content><![CDATA[<p>2015年：</p>
<ol>
<li>求num各数字之和；</li>
<li>测试字符C在字符号串S中出现的次数；</li>
<li>中国有句俗话叫“三天打鱼两天晒网”。某人1990年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是打鱼还是晒网<br>2017年：</li>
<li>选择分支结构，注意ceil函数</li>
<li>汉诺塔问题</li>
<li>字符串交换问题：字符串以A开头和以K结尾的单词进行交换</li>
<li>百钱买百鸡问题：百鸡问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？</li>
<li>最大约数辗转相除法；</li>
<li>文件操作：将数据写入fname.txt中</li>
<li>螺旋方阵</li>
<li>求方程组近似根：弦截法</li>
<li>斐波那契数列递归实现</li>
</ol>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>F021程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyecharts遇到的坑</title>
    <url>/posts/10521/</url>
    <content><![CDATA[<p>因为Pyecharts高版本不兼容低版本的问题，相同的语法在不同的版本就可能会出现一个能正常运行而一个出现报错的情况<br>常见的有导包时就有可能出现错误<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar,Pie,Line <span class="comment"># 1.x版本的语法</span></span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Bar,Pie,Line <span class="comment"># 0.5.x版本的语法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#若交换使用就会报错 </span></span><br></pre></td></tr></table></figure><br>还有<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar_1 = Bar(<span class="string">&quot;每天被领劵的数量&quot;</span>,width=<span class="number">1500</span>,height=<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在0.5.x版本下就是正确的，在1.x版本下就是错误的</span></span><br></pre></td></tr></table></figure><br>在用<code>pip</code>命令安装时默认安装的是高版本，下面是卸载<code>Pyecharts</code>的命令和安装低版本的命令<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pyecharts <span class="comment"># 默认安装高版本</span></span><br><span class="line">pip uninstall pyecharts <span class="comment"># 卸载pycharts(无论任何版本)</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyecharts==<span class="number">0.5</span><span class="number">.5</span> <span class="comment"># 安装0.5.5</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>解决innerHTML不能解析数据</title>
    <url>/posts/31746/</url>
    <content><![CDATA[<p>当使用<code>document.(&#39;div&#39;).innerHTML=`` </code>向页面追加内容时可能会出现变量不解析的情况。<br>正确姿势：<code>=</code>后面是<code>`` </code>,而不是单引号或双引号,只有<code>`` </code>才能解析。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">document.querySelector(&#x27;div&#x27;).innerHTML=`<span class="tag">&lt;<span class="name">h2</span>&gt;</span>编号：$&#123;resp.id&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>`	</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>解决php中跨域问题</title>
    <url>/posts/60349/</url>
    <content><![CDATA[<p>由于同源策略，经常会出现跨域问题，只需要在php代码前加上下面这些代码即可<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">header(<span class="string">&quot;Access-Control-Allow-Origin:*&quot;</span>);</span><br><span class="line">header(<span class="string">&#x27;Access-Control-Allow-Methods:POST&#x27;</span>);</span><br><span class="line">header(<span class="string">&#x27;Access-Control-Allow-Headers:x-requested-with, content-type&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax原理和使用</title>
    <url>/posts/35823/</url>
    <content><![CDATA[<ol>
<li><h4 id="http介绍"><a href="#http介绍" class="headerlink" title="http介绍"></a>http介绍</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP基于TCP,是面向连接的协议，建立需要通过<strong>三次握手</strong>，断开需要通过<strong>四次挥手</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;当连接断开时，客户端的<strong>最后一次挥手</strong>后会等待两个单位时间，若两个单位时间内没有收到任何响应，说明服务器关闭了，然后客户端也关闭；若两个单位时间内又收到了消息，说明服务器还没有关，客户端和服务端将继续沟通。<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210115125141.PNG" alt></p>
</li>
<li><h4 id="http协议的构成"><a href="#http协议的构成" class="headerlink" title="http协议的构成"></a>http协议的构成</h4><p><strong>请求</strong>：</p>
</li>
</ol>
<ul>
<li>请求头—request header<ul>
<li>URL</li>
<li>method</li>
<li>query</li>
</ul>
</li>
<li>请求体—request body<br><strong>响应</strong>：</li>
<li>响应头—request header<ul>
<li>content-type</li>
</ul>
</li>
<li>响应体—response body<ul>
<li>响应数据</li>
</ul>
</li>
</ul>
<p>当是<code>get</code>请求时,信息在<code>URL</code>中；当是<code>post</code>请求时，信息在<code>request body</code>中。<br><code>content-type</code>中表示返回的数据类型，返回的数据在<code>response body</code>中。</p>
<ol>
<li><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4>&nbsp;&nbsp;&nbsp;&nbsp;同步:代码按照前后顺序一行一行的执行；<br>&nbsp;&nbsp;&nbsp;&nbsp;异步：同时执行多行代码；<br>&nbsp;&nbsp;&nbsp;&nbsp;注：异步代码总是在同步代码之后执行；</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;现在的前后端交互采取前后端分离，我们会采用异步的JavaScript和XML或JSON格式来完成数据的局部刷新。因为它是异步的，所以不等待整需要个页面的刷新，只需要发送一个异步请求，什么时候请求的内容过来了，什么时候刷新局部页面</p>
<ol>
<li><h4 id="Ajax介绍"><a href="#Ajax介绍" class="headerlink" title="Ajax介绍"></a>Ajax介绍</h4>&nbsp;&nbsp;&nbsp;&nbsp;传统的项目前后端不分离，用户触发一个http请求服务器，然后服务器收到之后再做出响应给用户，并且返回一个新的页面，也就是说交互都是通过页面刷新或页面跳转来实现的。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种方式对于用户体验来讲其实并不友好，少量的数据更新也会引发整个页面重新请求，浪费了很大一部分资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;因此，我们希望有一种更好的方式，可以不用重新请求整个页面而达到更新部分数据的效果。<em>2005年，ajax(Asynchronous JavaScript And XML)出现，给前端带来了巨大的变化与革新。</em></p>
<ol>
<li><h4 id="Ajax的特点"><a href="#Ajax的特点" class="headerlink" title="Ajax的特点"></a>Ajax的特点</h4>优点：</li>
</ol>
<ul>
<li>不需要插件支持（一般浏览器且默认开启JavaScript即可）</li>
<li>用户体验极佳（不刷新页面即可获取可更新的数据）</li>
<li>提升Web程序的性能（在传递数据方面做到按需发送，不必整体提交）</li>
<li>减轻服务器和带宽的负担（将服务区的一些操作转移到客户端）</li>
</ul>
<p>缺点：</p>
<ul>
<li>前进、后退功能被破坏（因为Ajax永远在当前页面，不会记录前后页面）</li>
<li>搜索引擎的支持度不够（因为搜索引擎爬虫还不能理解JS引起变化数据的内容）</li>
</ul>
<ol>
<li><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4></li>
</ol>
<ul>
<li>100-199：表示连接继续</li>
<li>200-299：表示各种意义上的成功</li>
<li>300-399：表示重定向</li>
<li>400-499：表示各种客户端错误</li>
<li>500-599：表示各种服务端错误</li>
</ul>
<ol>
<li><h4 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h4>&nbsp;&nbsp;&nbsp;&nbsp;1.准备页面请求，创建XMLHttpRequest对象<br>&nbsp;&nbsp;&nbsp;&nbsp;2.使用XMLHttpRequest对象的open()和send()方法发送资源请求给服务器<br>&nbsp;&nbsp;&nbsp;&nbsp;3.后台计算<br>&nbsp;&nbsp;&nbsp;&nbsp;4.onreadystatechange函数，状态改变时发送数据回客户端，使用XMLHttpRequest对象的responseText或responseXML属性获得服务器的响应</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注：open()打开连接，send()向服务器发送资源;调用send()方法后要去监听onreadystatechange事件，当onreadystatechange状态改变时，说明后端发送数据给客户端，客户端接收数据。</p>
<ol>
<li><h4 id="Ajax-get"><a href="#Ajax-get" class="headerlink" title="Ajax(get)"></a>Ajax(get)</h4>具体流程看注释</li>
</ol>
<p>client代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMsg()&quot;</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="comment">// 1.创建一个XMLHttpRequest对象</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">			<span class="comment">// 2.调用open方法打开连接</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">// open方法有三个参数</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">// 1.请求的method</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">// 2.请求的url</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">// 3.是否异步，默认值为true</span></span></span><br><span class="line"><span class="javascript">			xhr.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;http://127.0.0.1/data.php?id=1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			<span class="comment">//3.发送请求</span></span></span><br><span class="line">			xhr.send();</span><br><span class="line"><span class="javascript">			<span class="comment">//4.监听状态的改变</span></span></span><br><span class="line"><span class="javascript">			xhr.onreadystatechange=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="comment">// 判断状态值 0-4 五种状态，4代表最终的完成</span></span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">					<span class="comment">// 判断状态码</span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="javascript">						<span class="comment">//将返回的字符串转换成json对象</span></span></span><br><span class="line"><span class="javascript">						<span class="keyword">var</span> resp=<span class="built_in">JSON</span>.parse(xhr.responseText);</span></span><br><span class="line"><span class="javascript">						<span class="built_in">console</span>.log(resp);</span></span><br><span class="line"><span class="javascript">						<span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).innerHTML=<span class="string">`</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>编号：$&#123;resp.id&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题：$&#123;resp.title&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>`		</span></span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>server代码：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 解决跨域问题</span></span><br><span class="line">header(<span class="string">&quot;Access-Control-Allow-Origin:*&quot;</span>);</span><br><span class="line">header(<span class="string">&#x27;Access-Control-Allow-Methods:POST&#x27;</span>);</span><br><span class="line">header(<span class="string">&#x27;Access-Control-Allow-Headers:x-requested-with, content-type&#x27;</span>);</span><br><span class="line"><span class="comment">//获取客户端get请求过来的数据</span></span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">//转换成json格式</span></span><br><span class="line"><span class="keyword">echo</span> json_encode(<span class="keyword">array</span>(<span class="string">&#x27;id&#x27;</span>=&gt;<span class="variable">$id</span>,<span class="string">&#x27;title&#x27;</span>=&gt;<span class="string">&#x27;Hello Ajax&#x27;</span>));</span><br></pre></td></tr></table></figure></p>
<ol>
<li><h4 id="Ajax-post"><a href="#Ajax-post" class="headerlink" title="Ajax(post)"></a>Ajax(post)</h4><p>get请求和post请求有很多地方都相同，注意不同的地方(注释处)<br>client代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMsg()&quot;</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// method为post</span></span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;http://127.0.0.1/data.php&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//设置请求头的content-type  指定了参数的发送方式</span></span></span><br><span class="line"><span class="javascript">        xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 在send里写需要发送的数据</span></span></span><br><span class="line"><span class="javascript">        xhr.send(<span class="string">&#x27;name=zhangsan&amp;age=18&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> resp=<span class="built_in">JSON</span>.parse(xhr.responseText);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(resp);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).innerHTML=<span class="string">`</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：$&#123;resp.name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：$&#123;resp.age&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>`</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>server代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 解决跨域问题</span></span><br><span class="line">header(<span class="string">&quot;Access-Control-Allow-Origin:*&quot;</span>);</span><br><span class="line">header(<span class="string">&#x27;Access-Control-Allow-Methods:POST&#x27;</span>);</span><br><span class="line">header(<span class="string">&#x27;Access-Control-Allow-Headers:x-requested-with, content-type&#x27;</span>);</span><br><span class="line"><span class="comment">//获取客户端get请求过来的数据</span></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$age</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;age&#x27;</span>];</span><br><span class="line"><span class="comment">//转换成json格式</span></span><br><span class="line"><span class="keyword">echo</span> json_encode(<span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span>=&gt;<span class="variable">$name</span>,<span class="string">&#x27;age&#x27;</span>=&gt;<span class="variable">$age</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="封装ajax-1"><a href="#封装ajax-1" class="headerlink" title="封装ajax(1)"></a>封装ajax(1)</h4><p>get封装：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMsg()&quot;</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//若无参数query为null</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//若有参数，&#123;&#125;</span></span></span><br><span class="line"><span class="javascript">        get(<span class="string">&#x27;http://127.0.0.1/data.php&#x27;</span>,&#123;<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(resp)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">//封装get请求</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//query： string,请求的地址</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//query： Object,请求携带的参数</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//callback: function,成功之后的回调</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//isJSON: boolean,是否转化为json格式</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url,query,callback,isJSON</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//若有参数,先把参数拼接在url后面</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(query)&#123;</span></span><br><span class="line"><span class="javascript">            url+=<span class="string">&#x27;?&#x27;</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> query)&#123;</span></span><br><span class="line"><span class="javascript">                url+=<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;query[key]&#125;</span>&amp;`</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//取出最后多余的&amp;</span></span></span><br><span class="line">            url=url.slice(0,-1)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">&#x27;get&#x27;</span>,url)</span></span><br><span class="line">        xhr.send()</span><br><span class="line"><span class="javascript">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> res=isJSON?<span class="built_in">JSON</span>.parse(xhr.responseText):xhr.responseText</span></span><br><span class="line">                    callback(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>post封装<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMsg()&quot;</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//若无参数query为null</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//若有参数，&#123;&#125;</span></span></span><br><span class="line"><span class="javascript">        post(<span class="string">&#x27;http://127.0.0.1/data.php&#x27;</span>,&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(resp)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">//封装post请求</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//query： string,请求的地址</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//query： Object,请求携带的参数</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//callback: function,成功之后的回调</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//isJSON: boolean,是否转化为json格式</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url,query,callback,isJSON</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//若有参数,先把参数拼接起来</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(query)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> query)&#123;</span></span><br><span class="line"><span class="javascript">                str+=<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;query[key]&#125;</span>&amp;`</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">//取出最后多余的&amp;</span></span></span><br><span class="line">            str=str.slice(0,-1)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">&#x27;post&#x27;</span>,url)</span></span><br><span class="line"><span class="javascript">        xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span></span><br><span class="line">        xhr.send(str)</span><br><span class="line"><span class="javascript">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> res=isJSON?<span class="built_in">JSON</span>.parse(xhr.responseText):xhr.responseText</span></span><br><span class="line">                    callback(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br><strong>注</strong>：测试时一定要注意，当前端发的方式和后端接受的方式不一样时，可能会报json格式错误</p>
<ol>
<li><h4 id="ajax封装-2"><a href="#ajax封装-2" class="headerlink" title="ajax封装(2)"></a>ajax封装(2)</h4>创建util.js<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个util对象，切记对象内的数据之间要有逗号隔开</span></span><br><span class="line"><span class="keyword">var</span> util=&#123;</span><br><span class="line">    <span class="comment">//封装get</span></span><br><span class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params">url,query,callback,isJSON</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//若有参数,先把参数拼接起来</span></span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(query)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> query)&#123;</span><br><span class="line">                str+=<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;query[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出最后多余的&amp;</span></span><br><span class="line">            str=str.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&#x27;post&#x27;</span>,url)</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">        xhr.send(str)</span><br><span class="line">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> res=isJSON?<span class="built_in">JSON</span>.parse(xhr.responseText):xhr.responseText</span><br><span class="line">                    callback(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装post</span></span><br><span class="line">    post:<span class="function"><span class="keyword">function</span> (<span class="params">url,query,callback,isJSON</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//若有参数,先把参数拼接起来</span></span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(query)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> query)&#123;</span><br><span class="line">                str+=<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;query[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出最后多余的&amp;</span></span><br><span class="line">            str=str.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&#x27;get&#x27;</span>,url)</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">        xhr.send(str)</span><br><span class="line">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> res=isJSON?<span class="built_in">JSON</span>.parse(xhr.responseText):xhr.responseText</span><br><span class="line">                    callback(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;sendMsg()&quot;</span>&gt;发送请求&lt;/button&gt;</span><br><span class="line"><span class="comment">//先引入js文件,然后调用即可</span></span><br><span class="line">&lt;script src=<span class="string">&quot;./util.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//若无参数query为null</span></span><br><span class="line">        <span class="comment">//若有参数，&#123;&#125;</span></span><br><span class="line">        util.post(<span class="string">&#x27;http://127.0.0.1/data.php&#x27;</span>,&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(resp)</span><br><span class="line">        &#125;,<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="ajax封装-3"><a href="#ajax封装-3" class="headerlink" title="ajax封装(3)"></a>ajax封装(3)</h4>server代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util=&#123;</span><br><span class="line">    <span class="comment">//param : Object&#123;method,url,query,callback,isJSON&#125;</span></span><br><span class="line">    ajax:<span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        <span class="keyword">if</span>(params.method === <span class="string">&#x27;get&#x27;</span>)&#123;</span><br><span class="line">            params.url+=<span class="string">&#x27;?&#x27;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> params.query)&#123;</span><br><span class="line">                params.url+=<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params.query[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">            params.url=params.url.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">            xhr.open(<span class="string">&#x27;get&#x27;</span>,params.url)</span><br><span class="line">            xhr.send()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(params.query)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> params.query)&#123;</span><br><span class="line">                str+=<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params.query[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出最后多余的&amp;</span></span><br><span class="line">            str=str.slice(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">&#x27;post&#x27;</span>,params.url)</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">        xhr.send(str)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> resp=params.isJSON ? <span class="built_in">JSON</span>.parse(xhr.responseText) : xhr.responseText</span><br><span class="line">                    params.callback(resp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
client代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMsg()&quot;</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./util.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">        util.ajax(&#123;</span><br><span class="line"><span class="javascript">        	method:<span class="string">&#x27;get&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        	isJSON:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        	url:<span class="string">&#x27;http://127.0.0.1/data.php&#x27;</span>,</span></span><br><span class="line">        	query:&#123;</span><br><span class="line"><span class="javascript">        		<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaoming&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        		<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span></span></span><br><span class="line">        	&#125;,</span><br><span class="line"><span class="javascript">        	callback:<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(resp)</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;)   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言函数数组传值</title>
    <url>/posts/35573/</url>
    <content><![CDATA[<p>C语言中,向函数传值的问题<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>* number)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	duplicate(number);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> *number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,number[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> number[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	duplicate(number);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> number[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,number[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中浅拷贝和深拷贝</title>
    <url>/posts/17594/</url>
    <content><![CDATA[<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝只拷贝一层,当列表中有嵌套时,嵌套的列表是指向而不是拷贝<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>]</span><br><span class="line">y=x.copy()</span><br><span class="line">print(<span class="string">&#x27;列表x的值为:&#x27;</span>,x)  <span class="comment">#列表x的值为: [1, 2, [3, 4], 5]</span></span><br><span class="line">print(<span class="string">&#x27;列表y的值为:&#x27;</span>,y)  <span class="comment">#列表y的值为: [1, 2, [3, 4], 5]</span></span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">print(<span class="string">&#x27;列表x修改后,列表x的值为:&#x27;</span>,x)   <span class="comment">#列表x修改后,列表x的值为: [1, 2, [100, 4], 5]</span></span><br><span class="line">print(<span class="string">&#x27;列表x修改后,列表y的值为:&#x27;</span>,y)   <span class="comment">#列表x修改后,列表y的值为: [1, 2, [100, 4], 5]</span></span><br><span class="line"><span class="comment">#当修改列表x第一层时因为数据是拷贝过去的,所以对y无影响;</span></span><br><span class="line"><span class="comment">#当修改列表x第二层时因为数据是指向，当修改列表x时,y也跟着修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝方法</span></span><br><span class="line"><span class="number">1.</span> 用copy函数</span><br><span class="line"><span class="number">2.</span> 引用copy模块,用copy模块里的copy函数</span><br></pre></td></tr></table></figure><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210112145922.png" alt></p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝是对列表所有数据都拷贝,新列表和原列表没有一点关系<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>]</span><br><span class="line">y=copy.deepcopy(x)</span><br><span class="line">print(<span class="string">&#x27;列表x的值为:&#x27;</span>,x)  <span class="comment">#列表x的值为: [1, 2, [3, 4], 5]</span></span><br><span class="line">print(<span class="string">&#x27;列表y的值为:&#x27;</span>,y)  <span class="comment">#列表y的值为: [1, 2, [3, 4], 5]</span></span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">print(<span class="string">&#x27;列表x修改后,列表x的值为:&#x27;</span>,x)   <span class="comment">#列表x修改后,列表x的值为: [1, 2, [100, 4], 5]</span></span><br><span class="line">print(<span class="string">&#x27;列表x修改后,列表y的值为:&#x27;</span>,y)   <span class="comment">#列表x修改后,列表y的值为: [1, 2, [3, 4], 5]</span></span><br><span class="line"><span class="comment"># 深拷贝只能用copy模块里的deepcopy函数进行拷贝</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python经典问题</title>
    <url>/posts/59786/</url>
    <content><![CDATA[<ol>
<li><h3 id="交换两个变量的值"><a href="#交换两个变量的值" class="headerlink" title="交换两个变量的值"></a>交换两个变量的值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line"><span class="comment"># 方法一:利用第三个变量实现</span></span><br><span class="line">c=b</span><br><span class="line">b=a</span><br><span class="line">a=c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二:利用运算符实现</span></span><br><span class="line">a=a+b</span><br><span class="line">b=a-b</span><br><span class="line">a=a-b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三:利用异或运算符实现</span></span><br><span class="line">a=a^b</span><br><span class="line">b=a^b</span><br><span class="line">a=a^b</span><br><span class="line"><span class="comment"># 原理 a^b^b==a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法四:使用Python特有的方法实现</span></span><br><span class="line">a,b=b,a</span><br></pre></td></tr></table></figure></li>
<li>for…in循环删除元素</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字符串</title>
    <url>/posts/35224/</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在Python中可以使用一对单引号或双引号；也可以使用三对单引号或双引号</span><br><span class="line">eg:</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;hello&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;hello&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">当字符串里面还有引号时，用单双引号嵌套使用，使表达的意思清晰</span><br><span class="line">eg:</span><br><span class="line">msg=<span class="string">&#x27;xiaoming say&quot;I am xiaoming&quot;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="字符串的转义字符"><a href="#字符串的转义字符" class="headerlink" title="字符串的转义字符\"></a>字符串的转义字符\</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \&#x27; ==&gt; 显示一个普通的单引号</span></span><br><span class="line"><span class="comment"># \&quot; ==&gt; 显示一个普通的双引号</span></span><br><span class="line"><span class="comment"># \n ==&gt; 表示一个换行</span></span><br><span class="line"><span class="comment"># \t ==&gt; 表示一个制表符</span></span><br><span class="line"><span class="comment"># \\ ==&gt; 表示一个普通的\</span></span><br><span class="line"><span class="comment"># r&#x27;字符串&#x27; ==&gt; 表示原生字符串，\n等会原生输出，不会表现特殊含义(r,R都可以)</span></span><br><span class="line">eg:</span><br><span class="line">x1=<span class="string">&#x27;I\&#x27;m xiaoming&#x27;</span>     <span class="comment"># 若不用转移字符对&#x27;进行转义，则在m之前最会被截断，从而报错，不是一个字符串</span></span><br><span class="line">x2=<span class="string">&#x27;你好\n世界&#x27;</span>     </span><br><span class="line"><span class="comment"># 打印是：</span></span><br><span class="line">你好</span><br><span class="line">世界</span><br><span class="line"><span class="comment">#中间会转行 </span></span><br><span class="line"><span class="comment">#若x3=&#x27;你好\\n世界&#x27;</span></span><br><span class="line"><span class="comment">#打印结果是 你好\n世界     #因为已经对\进行转义，转义后仅表示一个普通的\字符 </span></span><br><span class="line">m=<span class="string">&#x27;hello\tworld&#x27;</span></span><br><span class="line">n=<span class="string">r&#x27;hello\tworld&#x27;</span></span><br><span class="line">print(m) <span class="comment"># 打印 hello	world</span></span><br><span class="line">print(n) <span class="comment"># 打印 hello\tworld，因为r会使字符串保持原生</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="字符串下标"><a href="#字符串下标" class="headerlink" title="字符串下标"></a>字符串下标</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下标又被称为索引，表示第几个数据</span></span><br><span class="line"><span class="comment"># str,list,tuple类型的数据可以通过下标获取或操作数据</span></span><br><span class="line"><span class="comment"># 切记，字符串是不可变数据类型(原数据永远不会修改，是在原数据的基础上新产生的数据)</span></span><br><span class="line"><span class="comment"># 下标是用0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过下标来获取或则修改指定位置的数据</span></span><br><span class="line">word=<span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">print(word[<span class="number">4</span>]) <span class="comment"># 打印n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串是不可变数据类型</span></span><br><span class="line"><span class="comment"># 对于字符串的任何操作，都不会改变原有的字符串！！！</span></span><br><span class="line">word=<span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line"><span class="comment"># 不管对word做任何操作</span></span><br><span class="line">print(word)   <span class="comment"># word打印的结果恒为 zhangsan</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切片就是从字符串里复制一段指定的内容，生成一个新的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片语法</span></span><br><span class="line">m[star:end:step]    <span class="comment"># m是字符串的变量名</span></span><br><span class="line"><span class="comment"># 复制的内容中包含stat位，不包含end位</span></span><br><span class="line"><span class="comment"># step表示步长，每步取一个数据，step默认为1</span></span><br><span class="line">m[Index] <span class="comment"># 获取字符串指定下标的数据</span></span><br><span class="line">m[star:end] <span class="comment"># 获取从star到end的数据</span></span><br><span class="line">m[star:] <span class="comment"># 获取从star开始的所有数据</span></span><br><span class="line">m[:end] <span class="comment"># 获取从头开始到end的数据</span></span><br><span class="line">m[::] <span class="comment"># 从复制整个字符串</span></span><br><span class="line">m[::step] <span class="comment">#整个字符串每step复制一个数据</span></span><br><span class="line">m[star:end:step] <span class="comment">#获取从star到end,没step取一个数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意</span></span><br><span class="line"><span class="comment"># 1.步长不能为0，但可以为负</span></span><br><span class="line"><span class="comment"># 2.当步长为负时，从star位开始向前运算</span></span><br><span class="line"><span class="comment"># 3.当step&lt;0且star&lt;end时，截取的内容为空(因为从star开始向前找不到end)</span></span><br><span class="line"><span class="comment"># 4.当star和end都为负数，表示从右向左数</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="字符串常见操作"><a href="#字符串常见操作" class="headerlink" title="字符串常见操作"></a>字符串常见操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(x) <span class="comment"># 获取字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找相关方法</span></span><br><span class="line">x.find(a) <span class="comment"># 查找字符串x中,字符c串a的下标，失败返回-1(返回a第一次出现的)</span></span><br><span class="line">x.index(a)  <span class="comment"># 查找字符串x中,字符串a的下标，失败会报错(返回a第一次出现的)</span></span><br><span class="line">x.rfind(a)  <span class="comment"># 查找字符串x中,字符串a的下标，失败返回-1(返回a最后一次出现的)</span></span><br><span class="line">x.rindex(a)  <span class="comment"># 查找字符串x中,字符串a的下标，失败会报错(返回a最后一次出现的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断相关方法</span></span><br><span class="line"><span class="comment"># is开头的都是判断结果是bool值</span></span><br><span class="line">x.startswith(a) <span class="comment"># 判断是否以字符串a开头</span></span><br><span class="line">x.endswith(a) <span class="comment"># 判断是否以字符串a结尾</span></span><br><span class="line">x.isdigit() <span class="comment"># 判断是否是纯数字</span></span><br><span class="line">x.isalpha() <span class="comment"># 判断是否是纯字母</span></span><br><span class="line">x.isalnum() <span class="comment"># 判断是否由纯字母数字组成(纯数字,纯字母,字母数字混合都为True,但当有其他字符如空格时就是False)</span></span><br><span class="line">x.isspace() <span class="comment"># 检测字符串是否只由空格组成,只有空格返回True,否则返回False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">x.replace(a,b) <span class="comment"># 用b替换字符串x中的a    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割</span></span><br><span class="line"><span class="comment">#按照指定字符串分割 </span></span><br><span class="line">x.split(a) <span class="comment"># 用字符串a将字符串x分割成一个列表</span></span><br><span class="line">x.rsplit(a,b) <span class="comment"># 用字符串a将字符串x从左切b次分割成一个列表</span></span><br><span class="line">x.split(a) <span class="comment"># 用字符串a将字符串x分割成一个列表</span></span><br><span class="line">x.rsplit(a,b) <span class="comment"># 用字符串a将字符串x从右切b次分割成一个列表</span></span><br><span class="line"><span class="comment">#按照行分割</span></span><br><span class="line">x.splitlines() <span class="comment"># 在有换行出\n处分割</span></span><br><span class="line"><span class="comment">#按照指定字符串分成三部分</span></span><br><span class="line">x.partition(a) <span class="comment"># 在第一个a处将字符串x分成三部分:a左侧,a,a右侧</span></span><br><span class="line">x.rpartition(a) <span class="comment"># 在最后一个a处将字符串x分成三部分:a左侧,a,a右侧</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="修改大小写"><a href="#修改大小写" class="headerlink" title="修改大小写"></a>修改大小写</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.capitalize() <span class="comment"># 让字符串x第一个字符大写</span></span><br><span class="line">x.upper() <span class="comment"># 让字符串x中所有字符都大写</span></span><br><span class="line">x.lower() <span class="comment"># 让字符串x中所有字符都小写</span></span><br><span class="line">x.title() <span class="comment"># 让字符串x中所有单词首字母大写</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.ljust(width) <span class="comment"># 在字符串x的左边填空格，使字符串长度变为width(len(x)大于width，不做任何操作)</span></span><br><span class="line">x.rjust(width) <span class="comment"># 在字符串x的右边填空格，使字符串长度变为width(len(x)大于width，不做任何操作)</span></span><br><span class="line">x.center(width) <span class="comment"># 在字符串两侧平均填空格，使字符串长度变为width(len(x)大于width，不做任何操作)</span></span><br><span class="line">x.ljust(width,fillchar) <span class="comment"># 在字符串x的左边填filechar，使字符串长度变为width(len(x)大于width，不做任何操作)</span></span><br><span class="line">x.rjust(width,fillchar) <span class="comment"># 在字符串x的右边填filechar，使字符串长度变为width(len(x)大于width，不做任何操作)</span></span><br><span class="line">x.center(width,fillchar) <span class="comment"># 在字符串两侧平均填fillchar，使字符串长度变为width(len(x)大于width，不做任何操作)</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="增删空格"><a href="#增删空格" class="headerlink" title="增删空格"></a>增删空格</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.lstrip() <span class="comment">#去除x中左侧的空格</span></span><br><span class="line">x.rstrip() <span class="comment">#去除x中右侧的空格</span></span><br><span class="line">x.lstrip(chars) <span class="comment">#去除x中左侧的chars</span></span><br><span class="line">x.rstrip(chars) <span class="comment">#去除x中右侧的chars</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="列表、字符串之间的转化"><a href="#列表、字符串之间的转化" class="headerlink" title="列表、字符串之间的转化"></a>列表、字符串之间的转化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.split(<span class="built_in">str</span>) <span class="comment"># 用字符str把x分成一个list</span></span><br><span class="line"><span class="built_in">str</span>.join(chars) <span class="comment"># 用字符str把chars连接成一个字符串</span></span><br><span class="line"><span class="comment"># chars是一个可迭代的对象</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="字符串的运算符"><a href="#字符串的运算符" class="headerlink" title="字符串的运算符"></a>字符串的运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.字符串和字符串之间可以相加</span></span><br><span class="line"><span class="comment"># 2.字符串和数字之间可以相乘</span></span><br><span class="line"><span class="comment"># 3.字符串和数字之前：==为False；!=为True</span></span><br><span class="line"><span class="comment"># 4.字符串和字符串之间做比较运算，会逐个比较字符串的编码值</span></span><br><span class="line"><span class="comment"># 5.不支持其他运算符</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="利用内置函数实现数字、字符间的转化-ASCII码"><a href="#利用内置函数实现数字、字符间的转化-ASCII码" class="headerlink" title="利用内置函数实现数字、字符间的转化(ASCII码)"></a>利用内置函数实现数字、字符间的转化(ASCII码)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ord</span>(char) <span class="comment"># 查看字符char的ASCII码</span></span><br><span class="line"><span class="built_in">chr</span>(num) <span class="comment"># 查看ASCII码num所对应的字符</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="in-和-not-in"><a href="#in-和-not-in" class="headerlink" title="in 和 not in"></a>in 和 not in</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="comment"># 用来判断一个内容是否在可迭代对象中</span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span> <span class="comment"># 用来判断一个内容是否不在可迭代对象中</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="使用-占位符来格式化字符串"><a href="#使用-占位符来格式化字符串" class="headerlink" title="使用% 占位符来格式化字符串"></a>使用% 占位符来格式化字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %s    表示的是字符串的占位符</span></span><br><span class="line"><span class="comment"># %d    表示的整数的占位符</span></span><br><span class="line"><span class="comment"># %nd   打印时显示n位，如果不够，n&gt;0在前面用空格补齐,n&lt;0在后面补空格</span></span><br><span class="line"><span class="comment"># %0d   打印时显示n位，如果不够，在前面用0补齐</span></span><br><span class="line"><span class="comment"># %f    表示浮点数的占位符</span></span><br><span class="line"><span class="comment"># %nf   表示浮点数的占位符,四舍五入保留n为小数</span></span><br><span class="line"><span class="comment"># %%    打印一个%</span></span><br><span class="line"><span class="comment"># %x    将数字按16进制输出，字符为小写</span></span><br><span class="line"><span class="comment"># %X    将数字按16进制输出，字符为大写</span></span><br><span class="line"><span class="comment"># print(&#x27;%3d&#x27;% 15) ##语法</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;&#125; 可以用来占位，用format中的数据进行填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一一对应填充</span></span><br><span class="line"><span class="comment"># x=&#x27;大家好,我是&#123;&#125;,今年&#123;&#125;岁&#x27;.format(&#x27;xiaoming&#x27;,18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;数字&#125;，数字从0开始</span></span><br><span class="line"><span class="comment"># x=&#x27;大家好,我是&#123;1&#125;,今年&#123;0&#125;岁&#x27;.format(18,&#x27;xiaoming&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;变量名&#125;,相当于键值对</span></span><br><span class="line"><span class="comment"># x=&#x27;大家好,我是&#123;name&#125;,今年&#123;age&#125;岁&#x27;.format(name=&#x27;xiaoming&#x27;,age=18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;数字&#125;&#123;变量名&#125;混合使用</span></span><br><span class="line"><span class="comment"># x=&#x27;大家好,我是&#123;name&#125;,今年&#123;1&#125;岁,身高&#123;0&#125;cm&#x27;.format(180,18,name=&#x27;xiaoming&#x27;)</span></span><br><span class="line"><span class="comment"># 要先写数字的值，再写变量名的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用list填充</span></span><br><span class="line"><span class="comment"># data=[&#x27;xiaoming&#x27;,18,180]</span></span><br><span class="line"><span class="comment"># x=&#x27;大家好,我是&#123;&#125;,今年&#123;&#125;岁,身高&#123;&#125;cm&#x27;.format(*data)</span></span><br><span class="line"><span class="comment"># 切记加*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用dictionary填充</span></span><br><span class="line"><span class="comment"># data=&#123;&#x27;name&#x27;:&#x27;xiaoming&#x27;,&#x27;age&#x27;:18,&#x27;high&#x27;:180&#125;</span></span><br><span class="line"><span class="comment"># x=&#x27;大家好,我是&#123;name&#125;,今年&#123;age&#125;岁,身高&#123;high&#125;cm&#x27;.format(**data)</span></span><br><span class="line"><span class="comment"># 切记加**</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python可变数据类型和不可变数据类型</title>
    <url>/posts/15278/</url>
    <content><![CDATA[<p>Python中的数据分为可变数据类型和不可变数据类型</p>
<h3 id="可变数据类型"><a href="#可变数据类型" class="headerlink" title="可变数据类型"></a>可变数据类型</h3><p>定义：如果修改值，内存地址不会发生变化<br>可变数据类型:列表,字典,集合</p>
<h3 id="不可变数据类型"><a href="#不可变数据类型" class="headerlink" title="不可变数据类型"></a>不可变数据类型</h3><p>定义：如果修改值，内存地址会发生变化<br>可变数据类型:字符串,数字,元组</p>
<h3 id="看图理解"><a href="#看图理解" class="headerlink" title="看图理解"></a>看图理解</h3><p><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210111164602.png" alt><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210111165444.png" alt></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python运算符</title>
    <url>/posts/16318/</url>
    <content><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+:加</span><br><span class="line">-:减</span><br><span class="line">*:乘</span><br><span class="line">/:除(结果可以是<span class="built_in">float</span>)</span><br><span class="line">%:取余</span><br><span class="line">**:幂运算 eg: print(<span class="number">2</span>**<span class="number">3</span>) <span class="comment">#打印2的3次幂</span></span><br><span class="line">//:整除(向下取整)</span><br><span class="line">注：</span><br><span class="line"><span class="comment"># 可用幂运算进行开方运算</span></span><br><span class="line">eg:print(<span class="number">81</span>**(<span class="number">1</span>/<span class="number">2</span>)) <span class="comment">#打印的是81开平方的结果，即为9</span></span><br><span class="line"><span class="comment"># 在Python2中，/得到的是一个整数;在Python3中得到是一个浮点数</span></span><br><span class="line"><span class="comment"># 在开发中使用括号来表示优先级,比较清晰</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="算术运算符在字符串中的使用"><a href="#算术运算符在字符串中的使用" class="headerlink" title="算术运算符在字符串中的使用"></a>算术运算符在字符串中的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在字符串中有限度的支持加法和乘法运算符</span></span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>)   <span class="comment"># 结果为 helloworld(用于拼接字符串)</span></span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>*<span class="number">2</span>)         <span class="comment"># 结果为 hellohello</span></span><br><span class="line">注：字符串和数字是不能相加的</span><br><span class="line">print(<span class="string">&quot;a&quot;</span>+<span class="number">1</span>) <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span> <span class="comment"># 单个变量赋值</span></span><br><span class="line">m,n=<span class="number">1</span>,<span class="number">2</span> <span class="comment"># 多个变量赋值(拆包),且当等号左右两侧个数不相等时会报错</span></span><br><span class="line">o*,p,q=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> <span class="comment">#加*表示可变长度,把4,5分别赋给p,q,其余全部赋值给o</span></span><br><span class="line">m=<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span> <span class="comment"># 元组赋值</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较运算符</span></span><br><span class="line">&gt;:大于</span><br><span class="line">&lt;:小于</span><br><span class="line">&gt;=:大于等于</span><br><span class="line">&lt;=:小于等于</span><br><span class="line">!=:不等于(在python2&lt;&gt;也表示不等于，python3不支持)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较运算符在字符串中的使用</span></span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span>&lt;<span class="string">&#x27;b&#x27;</span>) <span class="comment"># 结果为true 按照ASCII码进行比较</span></span><br><span class="line">print(<span class="string">&#x27;abc&#x27;</span>&lt;<span class="string">&#x27;b&#x27;</span>) <span class="comment"># 结果为true,直接字符a,b相比得出结果</span></span><br><span class="line">print(<span class="string">&#x27;abc&#x27;</span>==<span class="string">&#x27;abc&#x27;</span>) <span class="comment"># 结果为true</span></span><br><span class="line">在数字和字符串之间做==为true,做!=比较为false</span><br></pre></td></tr></table></figure></li>
<li><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span>:逻辑与</span><br><span class="line"><span class="keyword">or</span>:逻辑或</span><br><span class="line"><span class="keyword">not</span>:逻辑非</span><br><span class="line"></span><br><span class="line"><span class="comment">#规则</span></span><br><span class="line">逻辑与规则:只有一个运算数是<span class="literal">False</span>,结果就为<span class="literal">False</span></span><br><span class="line">逻辑或规则:只有一个运算数是<span class="literal">True</span>,结果就为<span class="literal">True</span></span><br><span class="line">优先级:<span class="keyword">not</span> &gt; <span class="keyword">and</span> &gt; <span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#逻辑运算符的取值问题(逻辑运算结果不一定是bool值)</span></span><br><span class="line">print(<span class="number">3</span> <span class="keyword">and</span> <span class="string">&#x27;Hello&#x27;</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span>) </span><br><span class="line"><span class="comment"># 结果为0(按照逻辑与的运算规则,有False则False)</span></span><br><span class="line">print(<span class="number">3</span> <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 结果为3,逻辑或运算当有一个是True时，后面的将不会被执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#逻辑运算符的短路问题</span></span><br><span class="line"><span class="number">4</span> &gt; <span class="number">3</span> <span class="keyword">and</span> print(<span class="string">&#x27;hello world&#x27;</span>) </span><br><span class="line"><span class="comment"># 打印hello world</span></span><br><span class="line"><span class="number">4</span> &gt; <span class="number">3</span> <span class="keyword">or</span> print(<span class="string">&#x27;hello world&#x27;</span>) </span><br><span class="line"><span class="comment"># print将会短路，因为逻辑或前面已经是True,后面将不会被执行</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&amp;:按位与(都为<span class="number">1</span>取<span class="number">1</span>,否则取<span class="number">0</span>)</span><br><span class="line">|:按位或(有<span class="number">1</span>取<span class="number">1</span>,否则取<span class="number">0</span>)</span><br><span class="line">^:按位异或(不同取<span class="number">1</span>,相同取<span class="number">0</span>)</span><br><span class="line">~:按位取反(<span class="number">0</span>取<span class="number">1</span>,<span class="number">1</span>取<span class="number">0</span>)</span><br><span class="line">&lt;&lt;:左移(向左移,后面补<span class="number">0</span>)</span><br><span class="line">&gt;&gt;:右移(向右移,数据会丢失)</span><br><span class="line"><span class="comment"># 左移:x左移a位结果为x乘以2的a次方</span></span><br><span class="line"><span class="comment"># 右移:x右移a位结果为x除以2的a次方(取整)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中函数的使用</title>
    <url>/posts/51896/</url>
    <content><![CDATA[<ol>
<li>函数定义语法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># def 函数名(参数):</span></span><br><span class="line"><span class="comment">#    函数要执行的语句</span></span><br><span class="line">eg:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">person</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125;说：他明天去旅游&#x27;</span>.<span class="built_in">format</span>(person))</span><br></pre></td></tr></table></figure></li>
<li>传参<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.一一对应传参</span></span><br><span class="line">say(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.通过变量名给形参赋值</span></span><br><span class="line">say(person=<span class="string">&#x27;xiaoming&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>返回值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> a <span class="comment">#语法</span></span><br><span class="line"><span class="number">2.</span> 通常情况下只能<span class="keyword">return</span>一次</span><br><span class="line"><span class="number">3.</span> 如果一个函数没有返回值，那么它的返回值就是<span class="literal">None</span></span><br><span class="line"><span class="number">4.</span> 在特殊情况下(<span class="keyword">finally</span>语句)，一个函数可能会执行多个<span class="keyword">return</span>语句</span><br></pre></td></tr></table></figure></li>
<li>函数的注释<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在定义函数名的下一行按三对双引号，然后回车</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:param person:</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>全局变量和局部变量<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义在函数外的为全局变量</span><br><span class="line"><span class="number">2.</span> 定义在函数内的为局部变量</span><br><span class="line"><span class="number">3.</span> 如果局部变量和全局变量重名时，会在函数内部又定义一个新的局部变量，而不是修改变全局变量</span><br><span class="line"><span class="number">4.</span>如果在函数内部想要修改全局变量，则用<span class="keyword">global</span></span><br><span class="line">eg：想要在函数内部修改全局变量name</span><br><span class="line"><span class="keyword">global</span> name</span><br><span class="line">name=<span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line"><span class="number">5.</span>使用内置函数查看全局变量和局部变量</span><br><span class="line"><span class="built_in">globals</span>() <span class="comment"># 查看当前.py中的全局变量</span></span><br><span class="line"><span class="built_in">locals</span>()  <span class="comment"># 查看当前.py中的局部变量</span></span><br><span class="line"><span class="number">6.</span> 在Python中只有函数分作用域</span><br></pre></td></tr></table></figure></li>
<li>函数多个返回值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 函数返回多个结果，就是将多个数据打包成一个整体返回，可以使用列表和字典</span><br><span class="line"><span class="number">2.</span> 通常情况下使用元组</span><br><span class="line"><span class="number">3.</span> 接受多个返回值时，若一直返回值个数，可直接用变量分别接受</span><br><span class="line">eg:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">x,y=test()</span><br><span class="line">print(<span class="string">&#x27;x=&#123;&#125;,y=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x,y))</span><br></pre></td></tr></table></figure></li>
<li>缺省参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义：有些函数的参数是有默认参数，你传了用你的，不传用默认的</span><br><span class="line">eg:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">person=<span class="string">&#x27;xiaoming&#x27;</span></span>):</span></span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125;说：他明天去旅游&#x27;</span>.<span class="built_in">format</span>(person))</span><br><span class="line"></span><br><span class="line">say() <span class="comment"># 当say函数不传参数时，就使用默认参数</span></span><br></pre></td></tr></table></figure></li>
<li>特殊传参<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 当位置参数和关键字参数混合使用时，位置参数在前</span><br><span class="line">eg:</span><br><span class="line">say(<span class="string">&#x27;xiaoming&#x27;</span>,age=<span class="number">18</span>)  <span class="comment"># 位置参数前，关键字参数后</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 位置可变参数</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">name,*args</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;xiaoming&#x27;</span>)  <span class="comment"># args为空</span></span><br><span class="line">say(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">18</span>)  <span class="comment"># 18以元组的形式存在args里</span></span><br><span class="line"><span class="comment"># 多出来的可变参数会以元组的形式保存在args里</span></span><br><span class="line"><span class="comment"># 在定义函数参数时,先写位置参数再写可变位置参数，传参时也是</span></span><br><span class="line"><span class="comment"># 注意是一个*</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>可变关键字参数</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">name,**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">say(name=<span class="string">&#x27;xiaoming&#x27;</span>)  <span class="comment"># kwargs为空</span></span><br><span class="line">say(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">18</span>)  <span class="comment"># 18以元组的形式存在kwargs里</span></span><br><span class="line"><span class="comment"># 多出来的可变参数会以字典的形式保存在kwargs里</span></span><br><span class="line"><span class="comment"># 在定义函数参数时,先写位置参数再写可变位置参数，传参时也是</span></span><br><span class="line"><span class="comment"># 注意是**</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>当位置参数，可变位置参数，缺省参数，关键字参数，可变关键字参数同时出现时</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">位置参数，可变位置参数，缺省参数，关键字参数，可变关键字参数</span>)  </span></span><br><span class="line"><span class="function">#传参时也是一样</span></span><br></pre></td></tr></table></figure></li>
<li>注意事项 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 在Python中函数不允许重名,重名后一个会覆盖前一个</span><br><span class="line"><span class="number">2.</span> 函数名和变量名也不能重名</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python元组、列表、字典、集合</title>
    <url>/posts/9223/</url>
    <content><![CDATA[<ol>
<li><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元组和列表很像，用来保存多个数据</span></span><br><span class="line"><span class="comment"># 使用一对小括号(),来表示一个元组</span></span><br><span class="line"><span class="comment"># 元组是不可变数据类型,因此只能进行查，不能进行增删改</span></span><br><span class="line"><span class="comment"># 元组是一个有序的存储数据的容器，可以通过下标来获取元素</span></span><br><span class="line"><span class="comment"># 元组也可以遍历</span></span><br><span class="line"></span><br><span class="line">index <span class="comment"># 通过下标获取元素</span></span><br><span class="line">count <span class="comment"># 用来统计指定元素的个数</span></span><br><span class="line">x=(<span class="number">1</span>,)  <span class="comment">#表示只有一个元素的元组</span></span><br><span class="line"><span class="built_in">tuple</span>   <span class="comment"># 实现可迭代对象转化为元组(列表list也可以这样用)</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 当我们保存多个数据时可以使用列表(列表近似于C语言的数组)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 使用[]表示一个列表，列表里的每一个数据表示元素，中间用逗号隔开</span><br><span class="line">[<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;河南&#x27;</span>] <span class="comment"># 即表示一个列表，数据类型可以不同</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 可以使用<span class="built_in">list</span>(可迭代对象),将可迭代对象转换成一个列表</span><br><span class="line">eg：</span><br><span class="line">x=<span class="built_in">list</span>((<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>))</span><br><span class="line">print(x) <span class="comment"># 打印结果：[&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 可以通过下标获取修改列表即对列表进行切片</span><br><span class="line">注：A[m:n] <span class="comment"># 例如在对a进行切片时,从下标m开始,不包含下标为n的</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 增加列表元素</span><br><span class="line">append <span class="comment"># 在列表末尾加一个元素</span></span><br><span class="line">insert <span class="comment"># 在指定位置插入元素</span></span><br><span class="line">extend <span class="comment"># 将可迭代对象添加到末尾</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 删除列表元素</span><br><span class="line">remove <span class="comment"># 删除列表指定元素</span></span><br><span class="line">clear <span class="comment"># 清空列表</span></span><br><span class="line"><span class="keyword">del</span> <span class="comment">#删除一个列表元素</span></span><br><span class="line">pop <span class="comment">#移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 查询列表元素</span><br><span class="line">index <span class="comment"># 返回指定元素下标,不存在会报错</span></span><br><span class="line">count <span class="comment"># 返回指定元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 修改元素</span><br><span class="line">用下标定位到元素,直接赋值</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 调用列表的sort方法进行排序</span><br><span class="line">顺序排序:默认循序排序</span><br><span class="line">逆序排序:x.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> 内置函数<span class="built_in">sorted</span>排序</span><br><span class="line">新生成一个列表</span><br><span class="line"><span class="comment"># 注：sort排序是改变原列表的序列,sorted新生成一个列表</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> 列表逆序</span><br><span class="line">reverse:用函数</span><br><span class="line">x.[::-<span class="number">1</span>]:用切片法</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> 复制列表</span><br><span class="line">y=x <span class="comment"># x,y指向了同一个内存地址,会相互影响</span></span><br><span class="line">copy <span class="comment"># 新列表和原列表数据相同,内存地址不同,不会相互影响</span></span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> 使用<span class="keyword">for</span>...<span class="keyword">in</span>对列表进行循环遍历时,尽量不要对列表进行删除操作</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> 列表的嵌套</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]] <span class="comment"># 列表可以嵌套使用</span></span><br><span class="line"></span><br><span class="line"><span class="number">15.</span> 带下标进行<span class="keyword">for</span>...<span class="keyword">in</span>循环(一般用<span class="keyword">while</span>)</span><br><span class="line"><span class="keyword">for</span> i,room <span class="keyword">in</span> <span class="built_in">enumerate</span>(rooms) <span class="comment"># enumerate是关键字</span></span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> 列表推导式</span><br><span class="line"><span class="comment"># 用列表推导式创建一个列表,产生列表条件简单的时候使用</span></span><br><span class="line">nums=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment"># 产生0-9,这10个数据的列表</span></span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> 列表合并</span><br><span class="line">extend <span class="comment"># 将两个列表合并成一个列表</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典里的数据都是以键值对的形式保存的</span></span><br><span class="line"><span class="comment"># key,value之间使用冒号连接，多个键值对之间使用逗号连接</span></span><br><span class="line"><span class="comment"># key是不允许重复的,重复了后一个会覆盖前一个</span></span><br><span class="line"><span class="comment"># key只能是不可变数据类型，而value可以是任意数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.查找数据(因为字典是无序的数据类型,所以只能用key来查找值)</span></span><br><span class="line">x[<span class="string">&#x27;key&#x27;</span>] <span class="comment"># 查找不到会报错</span></span><br><span class="line">x.get[<span class="string">&#x27;key&#x27;</span>] <span class="comment"># 查找不到会默认返回None</span></span><br><span class="line">x.get[<span class="string">&#x27;key&#x27;</span>,default] <span class="comment"># 查找不到返回default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改和删除(若存在key则修改,不存在则删除)</span></span><br><span class="line">x[<span class="string">&#x27;key&#x27;</span>]=value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除</span></span><br><span class="line">pop(<span class="string">&#x27;key&#x27;</span>) <span class="comment"># 删除并返回,否则返回默认值</span></span><br><span class="line">pop(<span class="string">&#x27;key&#x27;</span>,default) <span class="comment"># 删除并返回,否则返回default</span></span><br><span class="line">popitem() <span class="comment"># 返回并删除字典中的最后一对键和值</span></span><br><span class="line">clear() <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> x[<span class="string">&#x27;key&#x27;</span>] <span class="comment"># 直接删除,无返回值</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>合并</span><br><span class="line">A.update(B) <span class="comment"># A,B合并成一个字典,并赋值给A</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>循环</span><br><span class="line">方法一:直接<span class="keyword">for</span>...<span class="keyword">in</span>循环遍历字典</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> x: <span class="comment"># for...in循环遍历获取的是key</span></span><br><span class="line">    print(x,<span class="string">&#x27;=&#x27;</span>,x[k])</span><br><span class="line"></span><br><span class="line">方法二:获取所有的key,再由key获取value</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> x.keys(): </span><br><span class="line">    print(x,<span class="string">&#x27;=&#x27;</span>,x[k])</span><br><span class="line"><span class="comment"># 一般不用这种方法,和方法一几乎相同,多此一举</span></span><br><span class="line"></span><br><span class="line">方法三:获取所有的value</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> x.values():</span><br><span class="line">    print(v)</span><br><span class="line"></span><br><span class="line">方法四:拆包获取key,value</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> x.items():</span><br><span class="line">    print(k,<span class="string">&#x27;=&#x27;</span>,v)</span><br><span class="line"><span class="comment"># 常用方法一和四</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 交换key和value的位置</span><br><span class="line">方法一:</span><br><span class="line">x1=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaoming&#x27;</span>&#125;</span><br><span class="line">x2=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> x1.items():</span><br><span class="line">    x2[v]=k</span><br><span class="line">方法二:字典推导式</span><br><span class="line">x=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaoming&#x27;</span>&#125;</span><br><span class="line">x1=&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> x.items() &#125;</span><br><span class="line">print(x1)</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>字典推导式</span><br><span class="line">x1=&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> x.items() &#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 集合是一个不重复的无序的数据类型</span></span><br><span class="line"><span class="comment"># 集合可以用&#123;&#125;或set表示</span></span><br><span class="line"><span class="comment"># &#123;&#125;有两种意思:字典、集合;当里面的数据不是键值对时表示字典</span></span><br><span class="line"><span class="comment"># 字典中不允许有重复元素,当有重复元素时会自动去重</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>增加元素</span><br><span class="line">add() <span class="comment"># 增加一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>清空集合</span><br><span class="line">clear() <span class="comment"># 清空集合</span></span><br><span class="line"><span class="built_in">set</span>() <span class="comment">#表示空集合</span></span><br><span class="line">&#123;&#125; <span class="comment"># 表示空列表</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 删除元素</span><br><span class="line">pop <span class="comment"># 随机删除一个</span></span><br><span class="line">remove <span class="comment"># 指定删除一个,若删除的元素不存在则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 合并</span><br><span class="line">union <span class="comment"># 两个集合合并在一起,生成一个新的集合</span></span><br><span class="line">A.update(B) <span class="comment"># 将B拼接在A里</span></span><br><span class="line"><span class="comment"># 被合并的那个是可迭代对象即可</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 集合支持很多运算符(但不支持加法)</span><br><span class="line">A-B <span class="comment"># A与B的差集,就是去掉A中,B中有的元素</span></span><br><span class="line">A&amp;b <span class="comment"># A与B的交集</span></span><br><span class="line">A|B <span class="comment">#A与B的并集</span></span><br><span class="line">A^B <span class="comment">#A和B差集的并集(即去掉AB中共有的元素,把其余的合并在一起)</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 特殊情况</span><br><span class="line"><span class="comment"># 当列表转化为集合,如果是数字会去重且自动按升序排序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h3 id="元组、列表、字典的区别"><a href="#元组、列表、字典的区别" class="headerlink" title="元组、列表、字典的区别"></a>元组、列表、字典的区别</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>元组(Tuple)</span><br><span class="line"><span class="comment"># (),有序，元素任意，元素不可变</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>列表(List)</span><br><span class="line"><span class="comment"># [],有序，元素任意，元素可变</span></span><br><span class="line"><span class="comment"># 与C语言的数组相似，不同的是C语言的数据类型要相同，list可以不同</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>字典(Dictionary)</span><br><span class="line"><span class="comment"># &#123;&#125;，无序，元素任意，元素可变</span></span><br><span class="line"><span class="comment"># 元素键值对存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表用extend合并,字典用update合并</span></span><br><span class="line"><span class="comment"># 元组和列表可以用加号使两个元组和列表合并成一个，字典不可以</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python分支语句和循环语句</title>
    <url>/posts/49927/</url>
    <content><![CDATA[<h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><ol>
<li><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件:</span><br><span class="line">    条件成立时，执行的语句</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; <span class="number">2</span> :</span><br><span class="line">    print(<span class="string">&quot;helloworld&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><h3 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件:</span><br><span class="line">    条件成立时，执行的语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    当<span class="keyword">if</span>中的条件不成立时，执行的语句</span><br><span class="line">eg:</span><br><span class="line">msg=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> msg==<span class="number">0</span> :</span><br><span class="line">    print(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; <span class="number">2</span> :</span><br><span class="line">    print(<span class="string">&quot;helloworld&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><h3 id="if…elif…else"><a href="#if…elif…else" class="headerlink" title="if…elif…else"></a>if…elif…else</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成立，执行语句</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    条件<span class="number">2</span>成立，执行语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    当所有条件都不成立时，执行的语句</span><br><span class="line">eg:</span><br><span class="line">msg=<span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt;msg&lt;<span class="number">3</span> :</span><br><span class="line">    print(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">3</span>&lt;= msg &lt;=<span class="number">10</span> :  <span class="comment">#在Python中，允许这样进行左右判断</span></span><br><span class="line">    print(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
</li>
<li><p>pass关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pass关键字在Python中没有意思，只是用来占位，保证代码的完整性</span></span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; <span class="number">2</span> :</span><br><span class="line">    <span class="keyword">pass</span>   <span class="comment"># pass无意义，保证代码完整性</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="if语句注意点"><a href="#if语句注意点" class="headerlink" title="if语句注意点"></a>if语句注意点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>区间判断</span><br><span class="line">在Python中可以进行连写判断,如 <span class="number">0</span>&lt;=msg&lt;=<span class="number">10</span></span><br><span class="line"><span class="number">2.</span>隐式类型转换</span><br><span class="line"><span class="keyword">if</span>后面需要一个<span class="built_in">bool</span>类型的值，若不是<span class="built_in">bool</span>类型的值，则会自动转换</span><br><span class="line">eg：</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> :</span><br><span class="line">    print(<span class="string">&quot;你好&quot;</span>) <span class="comment"># 1会自动转换成bool类型的值true</span></span><br><span class="line"><span class="number">3.</span>三元表达式(对<span class="keyword">if</span>...<span class="keyword">else</span>的简写)</span><br><span class="line">x=num1 <span class="keyword">if</span> num1 &gt; num2 <span class="keyword">else</span> num2</span><br><span class="line">eg:</span><br><span class="line">x=<span class="number">1</span> <span class="keyword">if</span> <span class="number">1</span> &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> </span><br><span class="line">print(x)   <span class="comment"># 打印出的结果为1</span></span><br><span class="line"><span class="number">4.</span> 在Python中不支持switch...case...</span><br><span class="line"><span class="number">5.</span> 在Python中使用强制缩进来表示语句之间的结构</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ol>
<li><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件:</span><br><span class="line">    条件成立时,执行的语句</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">while</span> <span class="number">2</span>&lt;<span class="number">3</span>:</span><br><span class="line">    print(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> iterable:</span><br><span class="line">    执行语句</span><br><span class="line"><span class="comment">#这个和别的语言有所区别,对于计算数的时候一般用range</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    print(i) <span class="comment"># 打印结果为0,1,2,3,4</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for...in循环的本质是不断的调用next方法查找下一个数据</span></span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> iterable:</span><br><span class="line">    执行语句</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(<span class="string">&quot;aaa&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><h3 id="for…else循环"><a href="#for…else循环" class="headerlink" title="for…else循环"></a>for…else循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> iterable:</span><br><span class="line">    执行语句</span><br><span class="line">    <span class="keyword">if</span> 条件判断:</span><br><span class="line">        <span class="keyword">break</span>   <span class="comment"># 若break被执行，则退出for...each循环，each不会被执行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句 <span class="comment"># 当for语句执行完后且没有被break,则最后再执行each语句</span></span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:   <span class="comment"># 当for里面break被执行，each就不会被执行</span></span><br><span class="line">    print(<span class="string">&quot;111&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>:终止本层循环</span><br><span class="line"><span class="keyword">continue</span>:终止本次循环</span><br></pre></td></tr></table></figure></li>
<li><h3 id="循环语句注意事项"><a href="#循环语句注意事项" class="headerlink" title="循环语句注意事项"></a>循环语句注意事项</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Python中没有i++或i--,只能i+=<span class="number">1</span></span><br><span class="line"><span class="number">2.</span> 常用<span class="built_in">range</span>内置类生成一个整数区间进行循环</span><br><span class="line"><span class="number">3.</span> <span class="built_in">range</span>生成的整数区间以前一个数开始，以后一个数的前一个整数结束</span><br><span class="line"><span class="number">4.</span> <span class="keyword">in</span>后面是一个可迭代的对象,目前接触到的接迭代的对象:字符串,列表,字典,元组,集合,<span class="built_in">range</span></span><br><span class="line"><span class="number">5.</span> Python中没有do...<span class="keyword">while</span>...</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2和Python3的区别(更新中)</title>
    <url>/posts/63675/</url>
    <content><![CDATA[<ol>
<li>在Python2中，/得到的是一个整数;在Python3中得到是一个浮点数</li>
<li>在python2中0o和0开始的数字都是8进制;在Python3中只有0o表示8进制</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中进制和数据类型转换</title>
    <url>/posts/57141/</url>
    <content><![CDATA[<ol>
<li><h3 id="二、八、十六进制转换"><a href="#二、八、十六进制转换" class="headerlink" title="二、八、十六进制转换"></a>二、八、十六进制转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  二进制:前缀,0b;<span class="number">0b11</span>;每个位最大不能超过<span class="number">1</span></span><br><span class="line">  八进制:前缀,0o;<span class="number">0o17</span>;每个位最大不能超过<span class="number">7</span></span><br><span class="line">十六进制:前缀,0x;<span class="number">0x1f</span>;每个位最大不能超过f</span><br><span class="line"><span class="comment"># 注：在python2中0o和0开始的数字都是8进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手算转换</span></span><br><span class="line"><span class="number">2</span>进制转换为<span class="number">8</span>：从后向前<span class="number">3</span>位一组进行</span><br><span class="line"><span class="number">2</span>进制转换为<span class="number">16</span>：从后向前<span class="number">4</span>位一组进行</span><br><span class="line"><span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>进制转换成十进制，都是按照幂次，然后相加进行计算</span><br><span class="line"><span class="number">10</span>进制转换成<span class="number">2</span>进制：除留余数法</span><br><span class="line"></span><br><span class="line"><span class="comment"># 机算</span></span><br><span class="line">a=<span class="number">12</span> <span class="comment">#10进制数</span></span><br><span class="line"><span class="built_in">bin</span>(a) <span class="comment"># 将10进制数转换成2进制</span></span><br><span class="line"><span class="built_in">oct</span>(a) <span class="comment"># 将10进制数转换成8进制</span></span><br><span class="line"><span class="built_in">hex</span>(a) <span class="comment"># 将10进制数转换成16进制</span></span><br><span class="line">注：当a不等于数字时会报错</span><br></pre></td></tr></table></figure></li>
<li>数据类型之间的转换<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换函数</span></span><br><span class="line">msg=<span class="built_in">int</span>(msg) </span><br><span class="line"><span class="comment"># 将不是int型的变量转换成int型的变量</span></span><br><span class="line"><span class="comment"># 其余类型写法相同，如float</span></span><br><span class="line"><span class="comment"># 当被转换的msg不是纯数字会转换失败，报错 </span></span><br><span class="line">msg=<span class="built_in">int</span>(x,y)</span><br><span class="line"><span class="comment"># 将字符串x,按照y进制转换成10进制数</span></span><br><span class="line">eg:</span><br><span class="line">msg=<span class="built_in">int</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="number">16</span>) <span class="comment"># 将字符串&#x27;abc&#x27;按照16进制数转换成10进制数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换原因</span></span><br><span class="line">不同的数据类型有时候不能进行运算</span><br><span class="line"></span><br><span class="line"><span class="comment"># True False</span></span><br><span class="line">在进行数据运算时,<span class="literal">True</span>=<span class="number">1</span>,<span class="literal">False</span>=<span class="number">0</span>;</span><br><span class="line">eg:</span><br><span class="line">print(<span class="literal">True</span> + <span class="number">1</span>)  <span class="comment"># 结果为2</span></span><br></pre></td></tr></table></figure></li>
<li>转换成布尔值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在数字里，只有0会被转换成False</span></span><br><span class="line"><span class="comment"># 在字符串里只有空字符串会被转换成False,空格串也会被转换成True</span></span><br><span class="line"><span class="comment"># None会被转换为False,eg:bool(None),打印出来是False</span></span><br><span class="line"><span class="comment"># 空数据类型会被转换成False,如[],(),&#123;&#125;等</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Python遇到的坑(更新中)</title>
    <url>/posts/4895/</url>
    <content><![CDATA[<ol>
<li><h3 id="在cmd中输入Python打开软件商店"><a href="#在cmd中输入Python打开软件商店" class="headerlink" title="在cmd中输入Python打开软件商店"></a>在cmd中输入Python打开软件商店</h3>&nbsp;&nbsp;&nbsp;&nbsp;原因：在系统环境变量和用户环境变量的<code>path</code>中，当<code>WindowsApps</code>在<code>python</code>所配置的环境变量前的时候，就会先打开<code>WindowsApps</code><br>&nbsp;&nbsp;&nbsp;&nbsp;解决方法：1.在系统环境和用户环境变量的<code>path</code>中删掉<code>WindowsApps</code>这一项；2.在系统环境和用户环境变量的<code>path</code>中将<code>WindowsApps</code>这一项移动到<code>python</code>环境变量的下面，这样<code>python</code>环境变量就会先被执行，不会造成那样的意外<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210108143304.png" alt></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm基本使用</title>
    <url>/posts/6348/</url>
    <content><![CDATA[<h2 id="Pycharm基本使用"><a href="#Pycharm基本使用" class="headerlink" title="Pycharm基本使用"></a>Pycharm基本使用</h2><ol>
<li>双击shift键(或Ctrl+shift+A)，会弹出全局搜索窗口</li>
<li>快速格式化代码 Ctrl+shift+L</li>
<li>快速复制粘贴选中代码 Ctrl+D</li>
<li>移动一行代码 Ctrl+shift+上下箭头</li>
<li>光标定位到一行开头Fn+左箭头，定位到一行结尾Fn+右箭头</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基本语法</title>
    <url>/posts/24577/</url>
    <content><![CDATA[<h2 id="Python基本语法"><a href="#Python基本语法" class="headerlink" title="Python基本语法"></a>Python基本语法</h2><ol>
<li>注释<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"><span class="comment"># ptint(&quot;Hello Python&quot;)  //用# 或ctrl+/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多行注释</span></span><br><span class="line"><span class="comment"># print(&quot;你好&quot;)</span></span><br><span class="line"><span class="comment"># print(&quot;您好&quot;) //先选中，然后用Ctrl+/</span></span><br></pre></td></tr></table></figure></li>
<li>变量<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量直接赋值</span></span><br><span class="line">msg=<span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>input输入<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg=<span class="built_in">input</span>(<span class="string">&quot;请输入&quot;</span>)</span><br><span class="line"><span class="comment"># msg为变量名</span></span><br><span class="line"><span class="comment"># input括号里为输入提示信息</span></span><br></pre></td></tr></table></figure></li>
<li>del删除<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span>(msg)</span><br><span class="line"><span class="comment"># msg：删除的变量名</span></span><br></pre></td></tr></table></figure></li>
<li>标识符规则</li>
</ol>
<ul>
<li>由字母，数字，下划线组成</li>
<li>开头不能是数字</li>
<li>不能是Python关键字</li>
</ul>
<ol>
<li>数据类型</li>
</ol>
<ul>
<li>str(字符串)</li>
<li>Number(数字)<ul>
<li>整数</li>
<li>浮点数</li>
<li>复数<code>msg=1+2j</code></li>
</ul>
</li>
<li>bool(布尔值)</li>
<li>None(空值)</li>
<li>list(列表)</li>
<li>tuple(元组)</li>
<li>dict(字典)</li>
<li>set(集合)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用type获取数据类型</span></span><br><span class="line">msg=<span class="number">123</span></span><br><span class="line">print(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>数据运算符的分类(与C语言一直的省略)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求幂 **</span></span><br><span class="line">print(<span class="number">2</span>**<span class="number">3</span>) <span class="comment"># 2的3次幂</span></span><br><span class="line"><span class="comment"># 取整 //</span></span><br><span class="line">print(<span class="number">12</span>//<span class="number">5</span>) <span class="comment"># 12对5取整</span></span><br></pre></td></tr></table></figure></li>
<li>符合运算符(写法与C一致)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=a+b</span><br><span class="line">等价于</span><br><span class="line">a+=b</span><br></pre></td></tr></table></figure></li>
<li>关系运算符(与C一致)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure></li>
<li>常用位运算符(将数字转化为二进制进行运算)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&amp; <span class="comment"># 按位与</span></span><br><span class="line">| <span class="comment"># 按位或</span></span><br><span class="line">^ <span class="comment"># 按位异或</span></span><br><span class="line">~ <span class="comment"># 按位取反</span></span><br><span class="line">&lt;&lt; <span class="comment"># 左移位</span></span><br><span class="line">&gt;&gt; <span class="comment"># 右移位</span></span><br></pre></td></tr></table></figure></li>
<li>print<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(a,b,c); </span><br><span class="line"><span class="comment"># 可以打印一个或多个变量或字符串</span></span><br><span class="line">print(value1,value2,value3,,sep=<span class="string">&#x27; &#x27;</span>,end=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># sep值用来设定输出时多个值之间的连接符，默认是空格</span></span><br><span class="line"><span class="comment"># end值用来设定输出结束时的结束符，默认是换行</span></span><br><span class="line"><span class="comment"># sep,end两者都是以键值对的形式出现</span></span><br></pre></td></tr></table></figure></li>
<li>input<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg=<span class="built_in">input</span>(<span class="string">&quot;提示信息&quot;</span>) </span><br><span class="line"><span class="comment"># input括号里保存的是提示信息</span></span><br><span class="line"><span class="comment"># 输入的信息会保存在变量msg</span></span><br><span class="line"><span class="comment"># 无论输入的是什么，msg的数据类型都为str</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo绑定域名</title>
    <url>/posts/48994/</url>
    <content><![CDATA[<ol>
<li><p><strong>注册域名</strong><br>可以挑选<a href="https://cloud.tencent.com/">腾讯云</a>或<a href="https://www.aliyun.com/">阿里云</a>，或则其余任何一家进行域名注册</p>
</li>
<li><p><strong>获取github仓库IP</strong><br>打开<code>cmd</code>,<code>ping 仓库名.github.io</code>,获取IP<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105215709.png" alt><br>我的这个ping的有点问题，但方法没错</p>
</li>
<li><strong>域名和IP绑定</strong><br>找到控制台，点解析<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105220220.png" alt><br>然后点击修改，按照下面图片提示<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105220540.png" alt></li>
<li><strong>创建CNAME文件</strong><br>在<code>blog/source</code>目录创建<code>CNAME(无后缀名)</code>,把申请的域名填入即可<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105215242.png" alt></li>
<li><strong>域名和github仓库绑定</strong><br>打开存放博客的仓库，点击<code>settings</code>,找到<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105214939.png" alt><br>在输入框输入申请的域名，然后点击<code>save</code></li>
<li><strong>访问</strong><br>域名，IP，<a href="https://仓库名.github.io，三则都可访问">https://仓库名.github.io，三则都可访问</a></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+PicGo+gitee图床</title>
    <url>/posts/13481/</url>
    <content><![CDATA[<p><strong>前言</strong>：我尝试了好几种床图，不是在电脑端加载不出来，就是有各种各样的限制，最后找到了gitee，因为服务器在国内，访问速度也是比较快，空间也没有限制，算是比较理想的一种吧。一开始我用vscode+PicGo插件，等到快成的时候，图片是上传上去了，但是加载不出来，我尝试了<code>sm.ms</code>和<code>github</code>，最后抛弃了<code>vsCode+PicGo</code>插件，选择了<code>PicGo客户端和gitee</code>。</p>
<ol>
<li><strong>注册gitee账号</strong><br>去官网注册账号<a href="https://gitee.com/">gitee</a></li>
<li><strong>新建gitee仓库</strong><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105203048.png" alt><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105203450.png" alt></li>
<li><strong>获得gitee的token</strong><br>登录<code>gitee</code>官网，点击头像/设置/私人令牌/生成令牌<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105203902.png" alt><br>点击提交后复制生成的令牌，在配置的时候要使用</li>
<li><strong>下载gitee</strong><br>点击<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>下载，有不同的版本，都可以<br>下载成功后按照提示默认安装即可</li>
<li><strong>配置gitee</strong><br>默认状态下PicGo是没有<code>gitee</code>，因此先安装插件<code>gitee-uploader</code><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105205151.png" alt><br>这时，点击图床设置，已经有<code>gitee图床</code>的设置<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105205522.png" alt> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:打开新建的仓库，看地址栏，若地址栏为https:&#x2F;&#x2F;gitee.com&#x2F;A&#x2F;B,则需要填A&#x2F;B</span><br><span class="line">2:默认为master就可以</span><br><span class="line">3:把刚才生成的token粘贴到这里</span><br><span class="line">4:path为创建的仓库存放图片的文件夹名，可以为image，可任意填写</span><br><span class="line">5:其余开心就好</span><br></pre></td></tr></table></figure></li>
<li><strong>升华</strong><br>为更方便地获取截图外链，安装<code>picgo-plugin-quick-capture</code>,实现截图上传一步搞定</li>
<li><strong>Typora+PicGo+gitee配置</strong><br>如果用<code>Typora</code>写<code>Markdown</code>文章，还需要对<code>Typora</code>进行配置，找到<code>文件/偏好设置/图像</code><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105212825.png" alt><br>在typora中，当插入本地图片时，会自动转换成gitee外链</li>
</ol>
<p><strong>tips</strong></p>
<ol>
<li>通过上面的操作已经实现了快速上传和快速截图上传功能，当我们要用本地图片生成外链时，先复制一下本地图片(就是选中图片按下Ctrl+c),然后按下快速上传的快捷键，此时外链已经生成，在需要插入图片的位置Ctrl+V就可以了</li>
<li>当使用快速截图上传时，如果是直接截图的话，截完图后直接Ctrl+V就可以了，但如果是截完图后需要写批注，那么截的图并不一定可以自动上传，需要按下快速上传的快捷键，然后再Ctrl+V</li>
<li>通过PicGo可以查看和删除上传的图片<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105212411.png" alt></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>PicGo</tag>
        <tag>gitee</tag>
        <tag>Typora</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo插入图片</title>
    <url>/posts/16600/</url>
    <content><![CDATA[<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol>
<li><p>在blog的本地文件的根目录中打开git Bash，然后执行<br><code>npm install hexo-asset-image --save</code></p>
</li>
<li><p>打开blog根目录下的配置文件_config.yml，修改<br><code>post_asset_folder: true  //由false改为true</code><br>此时，当执行<code>hexo n 文章名</code>的时候，会在_post目录下新建同名的一个文件夹和一个后缀名为<code>.md</code>的文件<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105173654.png" alt><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105173920.png" alt></p>
</li>
<li>打开<code>/node_modules/hexo-asset-image/index.js</code> 用下面代码替换<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var cheerio &#x3D; require(&#39;cheerio&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14480345&#x2F;how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version &#x3D; String(hexo.version).split(&#39;.&#39;);</span><br><span class="line">hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;</span><br><span class="line">  var config &#x3D; hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">        var link &#x3D; data.permalink;</span><br><span class="line">    if(version.length &gt; 0 &amp;&amp; Number(version[0]) &#x3D;&#x3D; 3)</span><br><span class="line">       var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 1) + 1;</span><br><span class="line">    else</span><br><span class="line">       var beginPos &#x3D; getPosition(link, &#39;&#x2F;&#39;, 3) + 1;</span><br><span class="line">    &#x2F;&#x2F; In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;...&#x2F;about&#x2F;index.html&quot;.</span><br><span class="line">    var endPos &#x3D; link.lastIndexOf(&#39;&#x2F;&#39;) + 1;</span><br><span class="line">    link &#x3D; link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess &#x3D; [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];</span><br><span class="line">    for(var i &#x3D; 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key &#x3D; toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ &#x3D; cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&#39;img&#39;).each(function()&#123;</span><br><span class="line">        if ($(this).attr(&#39;src&#39;))&#123;</span><br><span class="line">            &#x2F;&#x2F; For windows style path, we replace &#39;\&#39; to &#39;&#x2F;&#39;.</span><br><span class="line">            var src &#x3D; $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;&#x2F;&#39;);</span><br><span class="line">            if(!&#x2F;http[s]*.*|\&#x2F;\&#x2F;.*&#x2F;.test(src) &amp;&amp;</span><br><span class="line">               !&#x2F;^\s*\&#x2F;&#x2F;.test(src)) &#123;</span><br><span class="line">              &#x2F;&#x2F; For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.</span><br><span class="line">              &#x2F;&#x2F; In addition, to support multi-level local directory.</span><br><span class="line">              var linkArray &#x3D; link.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">                return elem !&#x3D; &#39;&#39;;</span><br><span class="line">              &#125;);</span><br><span class="line">              var srcArray &#x3D; src.split(&#39;&#x2F;&#39;).filter(function(elem)&#123;</span><br><span class="line">                return elem !&#x3D; &#39;&#39; &amp;&amp; elem !&#x3D; &#39;.&#39;;</span><br><span class="line">              &#125;);</span><br><span class="line">              if(srcArray.length &gt; 1)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src &#x3D; srcArray.join(&#39;&#x2F;&#39;);</span><br><span class="line">              $(this).attr(&#39;src&#39;, config.root + link + src);</span><br><span class="line">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">            console.info&amp;&amp;console.info($(this));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] &#x3D; $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>把自己想用的图片放在新建的文件夹(文章名的文件夹)中，在<code>test.md</code>中引用是<code>![](图片的文件名)</code><br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105183827.png" alt></li>
</ol>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ol>
<li>在<code>\blog\source</code>目录下新建<code>image</code>文件夹<br><img src="https://myforpicgo.oss-cn-beijing.aliyuncs.com/image/20210105184557.png" alt></li>
<li>把想要插入的图片都放入<code>image</code>文件夹下</li>
<li>在插入图片的位置引用<code>![](/image/图片名)</code>即可<br><strong>注</strong>：按照这种方式插入可能会在本地图片加载不出来，上传后就可以加载出来了；若上传后还加载不出来，检查blog根目录下的配置文件<code>_config.yml</code>的<code>post_asset_folder:</code>是否为<code>false</code></li>
</ol>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>用图床实现插入图片，也是最推荐的一种，具体见<a href="https://romanticqq.top/2021/01/05/hexo-PicGo-gitee%E5%9B%BE%E5%BA%8A/">hexo+PicGo+gitee图床</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>图床</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo备份与恢复</title>
    <url>/posts/49250/</url>
    <content><![CDATA[<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><ol>
<li>在github的博客仓库创建新的分支<strong>backup</strong></li>
<li><p>打开git Bash Here，输入</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加提交设置：打开blog/_config.yml在最后添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">backup:</span><br><span class="line">type: git</span><br><span class="line">repository:</span><br><span class="line">github: git@github.com:Romanticqq&#x2F;romanticqq.github.io.git,backup(提交的github地址,分支名)</span><br></pre></td></tr></table></figure></li>
<li>当要对代码备份时，执行<code>hexo d</code>即备份成功</li>
</ol>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><ol>
<li>把github的博客仓库<strong>backup</strong>分支的内容下载到本地</li>
<li>依次执行下列命令 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g # 如果是新电脑，要先执行这一行，安装hexo环境</span><br><span class="line">npm install hexo #先只执行这一行，如果hexo s报错再考虑执行下面的</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></li>
<li>本地文件恢复，<code>hexo s</code>开启本地服务，在浏览器输入<code>http://localhost:4000</code>测试是否正常<h2 id="当遇到提交失败时"><a href="#当遇到提交失败时" class="headerlink" title="当遇到提交失败时"></a>当遇到提交失败时</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">OpenSSL SSL_read: Connection was reset, errno <span class="number">10054</span></span><br><span class="line"><span class="comment">//在hexo d之前执行命令</span></span><br><span class="line">git config --<span class="keyword">global</span> http.sslVerify <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署</title>
    <url>/posts/55230/</url>
    <content><![CDATA[<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol>
<li>注册github账号(有github账号的可跳过)</li>
<li><p>登录后，新建一个代码仓库名为：github账号名.github.io,权限为public</p>
</li>
<li><p>实现git和github的链接</p>
<ol>
<li>鼠标右键打开git Bash Here</li>
<li>在git Bash Here中设置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li>然后再输入，获取密钥<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; </span><br></pre></td></tr></table></figure>
按照提示默认下一步，生成两个文件，按照所给出的路径，用记事本打开id_rsa.pub，并复制<ol>
<li>打开github的settings/SSH and GPG keys<br>点击SSH keys旁边的新建，在Title处给密钥起一个名字，并把密钥粘贴到Key处，</li>
<li>输入<code>ssh -T git@github.com</code>判断git和github是否连接成功</li>
</ol>
</li>
</ol>
</li>
<li>添加提交设置：打开blog/_config.yml在最后添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git   </span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;Romanticqq&#x2F;romanticqq.github.io.git &#x2F;&#x2F;提交的github仓库地址</span><br><span class="line">branch: master &#x2F;&#x2F;分支名</span><br></pre></td></tr></table></figure></li>
<li>进行部署 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F;清理public的内容</span><br><span class="line">hexo g &#x2F;&#x2F;生成静态内容</span><br><span class="line">hexo d  &#x2F;&#x2F;部署上传</span><br><span class="line">可能在上传时会报错，此时需要执行下面一句命令行</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li>访问<br>在浏览器地址栏输入<code>https://仓库名.github.io</code>,即可访问</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo个人博客</title>
    <url>/posts/13713/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>下载<a href="https://nodejs.org/en/">node.js</a></li>
<li>下载<a href="https://git-scm.com/downloads">git</a></li>
<li>配置环境变量<ol>
<li>在node.js的安装目录下创建的创建两个文件夹，分别为node_global和node_cache</li>
<li>配置：此电脑/属性/高级系统设置/环境变量,先找到用户环境变量Path，然后点击编辑，新建，把node_global的绝对路径添加上去，确定</li>
<li>然后找到系统环境变量的Path,点击编辑、新建，把nodejs的安装目录的绝对路径添加上去 </li>
</ol>
</li>
<li>更换node.js的源<ol>
<li>设置淘宝镜像源<br><code>npm config set registry https://registry.npm.taobao.org</code></li>
<li>查看使用的镜像源<br><code>npm config get registry</code></li>
<li>安装淘宝镜像源<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br><strong>注</strong>：可以更改也可以不更改，更换成国内的源后下载速度会变快，更改后以后执行npm命令要换成cnpm</li>
</ol>
</li>
</ol>
<h2 id="在本地搭建hexo"><a href="#在本地搭建hexo" class="headerlink" title="在本地搭建hexo"></a>在本地搭建hexo</h2><ol>
<li>在本地的任何一个磁盘创建一个文件夹blog(名字随意起)，为本地存储博客的文件夹</li>
<li>依次执行下列代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<ol>
<li>访问<code>http://localhost:4000</code></li>
</ol>
</li>
</ol>
<h2 id="选择自己喜欢的主题"><a href="#选择自己喜欢的主题" class="headerlink" title="选择自己喜欢的主题"></a>选择自己喜欢的主题</h2><ol>
<li>打开<a href="https://hexo.io/themes/">hexo主题</a>官网，选择自己喜欢的主题下载</li>
<li>下载完成后放在博客本地的文件夹里面，路径如：F:\blog\themes</li>
<li>修改配置文件F:\blog_config.yml<br>搜索：<strong>theme</strong>关键字<br>修改theme后的主题名，例如<br><code>theme: next</code>(切记：冒号和next之间有一个空格)</li>
<li>再次访问<code>http://localhost:4000</code>，看主题是否发生了变化,若主题改变了则说明主题修改成功了。</li>
<li>此时，博客本地搭建的已经成功了！</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda安装库时遇到的坑</title>
    <url>/posts/30138/</url>
    <content><![CDATA[<ol>
<li>注意要在安装库文件的目录下使用cmd，然后用命令安装</li>
<li>当安装完库成功后,import库发现不存在,可能是因为库的安装路径不在当前Python库的搜索路径内,所以没被找到.<br>解决方法:<br>(1)把库的路径加入搜索路径内;<br>(2)当安装Anaconda使,自带了Python,因此删掉自己安装的Python后再重新安装库即可，这样就会自动安装在搜索目录下了(新手尽量只装一个Python)</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
